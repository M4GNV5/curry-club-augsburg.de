<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Curry Club Augsburg</title>
        <link>http://curry-club-augsburg.de</link>
        <description><![CDATA[Neuigkeiten vom Curry Club Augsburg]]></description>
        <atom:link href="http://curry-club-augsburg.de/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 19 Mar 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Programm für das dreizehnte Treffen am 21. April 2016</title>
    <link>http://curry-club-augsburg.de/posts/2016-03-19-dreizehntes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das dreizehnte Treffen am 21. April 2016</h1>
    <div class="info">
      Gepostet am 19. Mär 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Sternenseemann und Lars stellen <strong>diesmal wirklich</strong> generische Programmierung jeweils in Haskell mit <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html">GHC.Generics</a> und in Scala mit <a href="https://github.com/milessabin/shapeless">shapeless</a> vor.</p>
<p>Profpatsch zeigt, wie man mit Haskell und Nix „Shellskripte“ schreiben kann.</p>
<p>Außerdem setzt Makarius die Reihe <em>Schönheit und Kunst</em> mit weiterer Arbeit in Isabelle fort.</p>
</article>
]]></description>
    <pubDate>Sat, 19 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2016-03-19-dreizehntes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Yolomorphismus</title>
    <link>http://curry-club-augsburg.de/posts/2016-02-27-yolomorphismus.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Yolomorphismus</h1>
    <div class="info">
      Gepostet am 27. Feb 16
      
          von Profpatsch
      
    </div>
    
    <img src="/images/yolo-cat.jpg" alt="Yolo-Katze" />
    
    
  </header>

  <p>Im Zuge unserer Unterhaltungen sind wir auf die Begrifflichkeit des „Yolomorphismus“ gekommen, welche Lars folgendermaßen definiert:</p>
<dl>
<dt>
<dfn>Yolomorphisums</dfn>, n.
</dt>
<dd>
partielle, nicht-injektive Funktion
</dd>
</dl>
<p>Beispiele sind die allseits gefürchteten <code>head</code> und <code>tail</code>, sowie <code>(!!)</code>.</p>
<p>Ingo ergänzte um Beispiele im weiteren Sinn (YOLO ernst genommen):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unsafePerformIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a

<span class="ot">unsafeCoerce ::</span> a <span class="ot">-&gt;</span> b  <span class="co">-- mehr YOLO geht nicht</span></code></pre></div>
<p>Lukas merkte noch an, dass man das alles wunderbar in ein Language-Feature umwandeln kann:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Yolomorphism</span> <span class="kw">where</span>

<span class="fu">--|</span> <span class="dt">Yolomorphism</span> typeclass
<span class="kw">class</span> <span class="dt">Yolomorphable</span> a <span class="kw">where</span>
  <span class="fu">--|</span> because <span class="dt">YOLO</span>
<span class="ot">  yoloPerformIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a
  <span class="fu">--|</span> because even more <span class="dt">YOLO</span>
<span class="ot">  yoloCoerce    ::</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Wir sollten das mal dem Haskell’-Team zur Einführung in die <code>base</code>-Library vorschlagen.</p>
</article>
]]></description>
    <pubDate>Sat, 27 Feb 2016 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2016-02-27-yolomorphismus.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Programm für das zwölfte Treffen am 17. März 2016</title>
    <link>http://curry-club-augsburg.de/posts/2016-02-26-zwoelftes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das zwölfte Treffen am 17. März 2016</h1>
    <div class="info">
      Gepostet am 26. Feb 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Cornelius setzt seinen Vortrag über <em>Verified Firewall Ruleset Analysis</em> fort.</p>
<p>Makarius gibt (diesmal wirklich) eine Einführung in <em>Programme und Beweise in Isabelle/HOL</em>. Inhaltlich werden das einige formale Fußnoten in klassicher Mathematik zu <a href="https://www.youtube.com/watch?v=F53aOAW9PBo">scheinbar unmöglichen funktionalen Programmen</a> sowie eine Nacharbeit zu den beiden Haskell-Workshops (<a href="https://curry-club-aux.github.io/haskell-workshop/uebung.pdf">erstes Übungsblatt</a>, <a href="https://curry-club-aux.github.io/haskell-workshop/uebung2.pdf">zweites Übungsblatt</a>) sein. Bei der Gelegenheit können wir auch den ersten Release Candidate von Isabelle2016 feiern, der am Tag des Treffens wahrscheinlich veröffentlicht wird.</p>
</article>
]]></description>
    <pubDate>Fri, 26 Feb 2016 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2016-02-26-zwoelftes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Programm für das elfte Treffen am 25. Februar 2016</title>
    <link>http://curry-club-augsburg.de/posts/2016-01-05-elftes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das elfte Treffen am 25. Februar 2016</h1>
    <div class="info">
      Gepostet am  5. Jan 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Ingo stellte kombinatorische Spieltheorie mit surrealen Zahlen und Haskell vor.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/Xm-CvksUxT0" frameborder="0" allowfullscreen>
</iframe>
<p>Cornelius sprach über <em>Verified Firewall Ruleset Analysis</em>. Diesen Vortrag hat er schon auf dem Kongress gehalten.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/fKeGfbY5AyM" frameborder="0" allowfullscreen>
</iframe>
<p>Beim nächsten Treffen wird er seinen Vortrag fortsetzen.</p>
<p>Makarius und Lukas mussten ihre Vorträge leider absagen. Auch Profpatsch’ Kurvvortrag fand nicht statt. Die Vorträge werden beim nächsten oder übernächsten Treffen nachgeholt.</p>
<!--more-->
<blockquote>
<p><strong>Kombinatorische Spieltheorie mit surrealen Zahlen und Haskell</strong></p>
<p>Rundenbasierte Zwei-Personen-Spiele, die keinerlei Zufallselemente enthalten und nicht mit verborgenen Informationen arbeiten, lassen sich mit einer wunderschönen mathematischen Theorie beschreiben. (“Schach”, nicht “Fußball”.)</p>
<p>Dabei ordnet man jeder Spielsituation einen gewissen Wert zu. Ist dieser positiv, gewinnt der eine Spieler; ist sie negativ, gewinnt der andere. Wenn eine Situation in zwei unabhängige Teile zerfällt, ist der zugeordnete Wert die Summe der Einzelwerte.</p>
<p>Gewöhnliche Zahlen genügen dafür aber nicht! Man verwendet stattdessen surreale Zahlen (und eine leichte Variante), eine elegante Neuschöpfung und weitreichende Verallgemeinerung der gewöhnlichen bekannten Zahlen. In den surrealen Zahlen haben Ausdrücke wie “unendlich”, “unendlich plus 1” und “unendlich minus 37” eine sinnvolle Bedeutung und werden in der Spielanalyse anschaulich.</p>
<p>Die grundlegenden Operationen mit surrealen Zahlen kann man elegant in Haskell implementieren. Mathematische Vorkenntnisse benötigt man dafür nicht, da man alles an grafischen Spielen ablesen kann. Damit können wir dann Gewinnstrategien für diverse Spiele berechnen lassen.</p>
<p><a href="http://rawgit.com/iblech/vortrag-haskell/master/surreal.pdf">“Folien”</a>, <a href="https://github.com/iblech/vortrag-haskell/blob/master/surreal.hs">Quellcode</a></p>
</blockquote>
<blockquote>
<p><strong>Verified Firewall Ruleset Analysis</strong></p>
<p>We develop a tool to verify Linux netfilter/iptables firewalls rulesets. Then, we verify the verification tool itself.</p>
<p>Warning: involves math!</p>
<p>This talk is also an introduction to interactive theorem proving and programming in Isabelle/HOL. We strongly suggest that audience members have some familiarity with functional programming. A strong mathematical background is NOT required.</p>
<p>TL;DR: Math is cool again, we now have the tools for “executable math”. Also: iptables!</p>
<p><a href="http://www.net.in.tum.de/pub/diekmann/32c3.pdf">Folien</a>, <a href="https://github.com/diekmann/Iptables_Semantics">Quellcode</a></p>
</blockquote>
</article>
]]></description>
    <pubDate>Tue, 05 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2016-01-05-elftes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Zweiter großer Haskell-Workshop des Curry Clubs Augsburg am 20. Dezember 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-09-zweiter-workshop.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Zweiter großer Haskell-Workshop des Curry Clubs Augsburg am 20. Dezember 2015</h1>
    <div class="info">
      Gepostet am  9. Dez 15
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <div class="right">
<p><a href="/files/haskellworkshop-plakat2.pdf"> <img width="300" src="/files/haskellworkshop-plakat2.png" /> </a></p>
</div>
<p>Liebe Freundinnen der Sonne!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu der Fortsetzung unseres <strong>Haskell-Workshops</strong> ein. Diese findet am <strong>20. Dezember 2015</strong>, einem Sonntag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Wie beim ersten Mal ist die Teilnahme kostenlos.</p>
<p>Zielgruppe des Workshops sind alle Teilnehmerinnen des ersten Workshops sowie Einsteigerinnen auf allen Fortschrittslevels.</p>
<p>Mit den Teilnehmerinnen vom letzten Mal werden wir dort weitermachen, wo wir das letzte Mal aufgehört haben. Während es damals darum ging die Basics zu lernen, wollen wir dieses Mal auf folgende Fragen eingehen:</p>
<ul>
<li>Welche verwendungsfertige Funktionen gibt es in der Standardbibliothek und auf <a href="http://hackage.haskell.org/">Hackage</a>?</li>
<li>Wie strukturiere ich größere Haskell-Programme?</li>
<li>Wie kann ich sicherstellen, dass mein Code das tut, was er soll?</li>
<li>Ich programmiere liebend gerne Parser / Webseiten / numerische Simulationen / Benutzeroberflächen / 3D-Spiele / XYZ. Wie mache ich das in Haskell?</li>
</ul>
<p>Am Anfang werden wir Monaden wiederholen. Ingo hat dazu auch einen <a href="/posts/2015-10-27-monaden-in-haskell.html">eigenen Blog-Post</a> geschrieben. Ihr tut euch mit Monaden erheblich leichter, wenn ihr diesen Artikel vor dem Workshop liest! Falls ihr das letzte Mal nicht fertig geworden seid, dann ist das kein Problem. Dann könnt ihr einfach das <a href="https://github.com/curry-club-aux/haskell-workshop/raw/gh-pages/uebung.pdf">Übungsblatt</a> weiter bearbeiten und wir helfen euch dabei.</p>
<p>Für Neueinsteigerinnen wird es eine eigene Gruppe geben. Teilnahmevoraussetzung für Neulinge ist entweder Erfahrung mit einer beliebigen anderen Programmiersprache oder Vertrautheit mit mathematisch/abstraktem Denken.</p>
<p>Wer vorhat, am Workshop teilzunehmen, kann sich in ein <a href="https://ola.pads.ccc.de/haskell-workshop-2015b">Organisationspad</a> eintragen und dann am 20. Dezember mit dem eigenen Laptop ins OpenLab kommen. Bitte vorab die <a href="https://www.haskell.org/platform/">Haskell Platform</a> installieren, um auf dem Workshop Zeit zu sparen.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<!--more-->
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></description>
    <pubDate>Wed, 09 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-09-zweiter-workshop.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Scheinbar unmögliche Programme</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-06-impossible-programs.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Scheinbar unmögliche Programme</h1>
    <div class="info">
      Gepostet am  6. Dez 15
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span></code></pre></div>
<p>Mit <code>[Bool]</code> meinen wir den Typ der unendlichen 0/1-Folgen.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> p1, p2,<span class="ot"> p3 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> p1 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">3</span>
<span class="ot">&gt;</span> p2 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">4</span>
<span class="ot">&gt;</span> p3 xs <span class="fu">=</span> xs<span class="fu">!!</span>(<span class="dv">2</span><span class="fu">+</span><span class="dv">1</span>) <span class="fu">&amp;&amp;</span> (xs<span class="fu">!!</span><span class="dv">8</span> <span class="fu">||</span> not (xs<span class="fu">!!</span><span class="dv">8</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test1 <span class="fu">=</span> p1 <span class="fu">==</span> p2
<span class="ot">&gt;</span> test2 <span class="fu">=</span> p1 <span class="fu">==</span> p3</code></pre></div>
<p>Das liefert einen Fehler über eine fehlende <code>Eq</code>-Instanz, oder? Weit gefehlt! Beide Programme terminieren. <code>test1</code> hat den Wert <code>False</code>, <code>test2</code> hat den Wert <code>True</code>.</p>
<p>Das ist umso erstaunlicher, wenn man bedenkt, dass <code>[Bool]</code> <em>überabzahlbar unendlich groß ist</em>.</p>
<p><strong>Hintergrund: Abzählbarkeit und Überabzählbarkeit</strong></p>
<p>Eine Menge heißt genau dann <em>abzählbar</em>, wenn es eine unendliche Liste gibt, in der alle Elemente der Menge vorkommen.</p>
<p>Prototypbeispiel: Die Menge N der natürlichen Zahlen ist abzählbar.</p>
<pre><code>0, 1, 2, 3, 4, ...</code></pre>
<p>Die Menge Z der ganzen Zahlen ist ebenfalls abzählbar, insbesondere also genau so groß wie die Menge der natürlichen Zahlen:</p>
<pre><code>0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, ...</code></pre>
<p>Übungsaufgabe: Zeige, dass auch die Menge Q der rationalen Zahlen abzählbar ist.</p>
<p>Eine Menge heißt genau dann <em>überabzählbar</em>, wenn sie nicht abzählbar ist.</p>
<p>Beispiel (Cantor): Die Menge R der reellen Zahlen ist überabzählbar.</p>
<p>Oder: Die Menge [Bool] aller unendlichen 0/1-Folgen ist überabzählbar.</p>
<p>Beweis durch das Cantorsche Diagonalargument:</p>
<p>Keine Liste von 0/1-Folgen kann <em>alle</em> 0/1-Folgen enthalten. Denn wenn zum Beispiel folgende Liste gegeben ist:</p>
<pre>
01000101011011011...
11101011111101111...
10101010101010101...
11100011100010010...
10010101100100000...
11010101100100000...
.
.
.
</pre>
<p>Wenn man nun die Diagonale (von oben links nach unten rechts) durchgeht, und jeweils die Gegenziffer wählt, erhält man eine 0/1-Folge, die sicher nicht in der Liste vorkommt. Im Beispiel wäre das</p>
<pre>100110...</pre>
<p>Diese 0/1-Folge kann nicht das erste Element der Liste sein, denn sie unterscheidet sich vom ersten Element ja an der vordersten Stelle. Sie kann auch nicht das zweite Element der Liste sein, denn sie unterscheidet sich vom zweiten Element ja an der zweitvordersten Stelle. Und so weiter!</p>
<p><strong>Epsilon</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, d.h. falls es eine 0/1-Folge <code>xs</code> gibt, sodass <code>p xs</code>, dann soll <code>epsilon p</code> irgendeine 0/1-Folge sein, sodass <code>p (epsilon p)</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, dann kann <code>epsilon p</code> sein, was es möchte.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; epsilon ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> epsilon p <span class="fu">=</span> <span class="kw">if</span> p (<span class="dt">False</span> <span class="fu">:</span> xs)
<span class="ot">&gt;</span>     <span class="kw">then</span> <span class="dt">False</span> <span class="fu">:</span> xs
<span class="ot">&gt;</span>     <span class="kw">else</span> <span class="dt">True</span>  <span class="fu">:</span> epsilon (p <span class="fu">.</span> (<span class="dt">True</span><span class="fu">:</span>))
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon (p <span class="fu">.</span> (<span class="dt">False</span><span class="fu">:</span>))</code></pre></div>
<p>Etwas schneller geht es dank Lazyness so:</p>
<pre><code>epsilon :: ([Bool] -&gt; Bool) -&gt; [Bool]
epsilon p = h : epsilon (p . (h:))
    where
    h = not $ p (False : epsilon (p . (False:)))</code></pre>
<p>Wer es noch schneller möchte – sodass auch Code wie <code>epsilon $ \xs -&gt; xs !! (10^10)</code> funktioniert, kann sich den Code von Martín Escardó ansehen.</p>
<p><strong>exists</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, dann soll <code>exists p</code> ein Zeuge dieser Erfüllbarkeit sein (in einem Maybe verpackt), also eine 0/1-Folge <code>xs</code>, sodass <code>p xs</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, soll <code>exists p</code> <code>Nothing</code> sein.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; exists ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> exists p <span class="fu">=</span> <span class="kw">if</span> p xs <span class="kw">then</span> <span class="dt">Just</span> xs <span class="kw">else</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon p</code></pre></div>
<p><strong>forall</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p><code>forall p</code> soll dann und nur dann True sein, falls `<code>p auf jeder 0/1-Folge konstant</code>True` ist.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; forall ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> forall p <span class="fu">=</span> isNothing <span class="fu">$</span> exists (not <span class="fu">.</span> p)</code></pre></div>
<p>Punktfrei geht es auch:</p>
<p><code>forall = not . isJust . exists . (not .)</code></p>
<p><strong>Eq-Instanz für Funktionen [Bool] -&gt; Bool</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Eq</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="kw">where</span>
<span class="ot">&gt;</span>     f <span class="fu">==</span> g <span class="fu">=</span> forall <span class="fu">$</span> \xs <span class="ot">-&gt;</span> f xs <span class="fu">==</span> g xs
<span class="ot">&gt;</span>     <span class="co">-- &quot;zwei Prädikate sind genau dann gleich, wenn sie auf jedem Argument</span>
<span class="ot">&gt;</span>     <span class="co">-- gleich sind&quot;</span></code></pre></div>
<p><strong>Exkurs: Beispiel für eine unstetige Funktion</strong></p>
<p>Eine Funktion von R nach R ist genau dann stetig, wenn man ihren Graph zeichnen kann, ohne den Stift abzusetzen. Eine stetige Funktion darf also keine Sprungstellen besitzen.</p>
<pre>
f : R --> R

x |-> if x < 0 then -1 else if x == 0 then 0 else 1

</pre>
<p>Die Signumfunktion!</p>
<p>Sie ist aber nur definiert auf der Teilmenge</p>
<pre>{ x in R | x < 0 oder x = 0 oder x > 0 }.</pre>
<p>Konstruktiv kann man nicht zeigen, dass diese Teilmenge ganz R ist. Die Funktion ist also nicht als total nachweisbar.</p>
<p><strong>Wieso funktionieren die “scheinbar unmöglichen Programme”?</strong></p>
<ol style="list-style-type: decimal">
<li><p>In Haskell kann man nur stetige Funktionen implementieren. (Wie in manchen Schulen konstruktiver Mathematik auch.) Jede Funktion vom Typ <code>[Bool] -&gt; Bool</code> ist stetig.</p></li>
<li><p>In der Topologie gibt es folgenden Satz: Jede stetige Funktion, deren Definitionsmenge kompakt ist, ist schon gleichmäßig stetig.</p></li>
</ol>
<p>Die Menge <code>[Bool]</code> ist kompakt. (Eigentlich sollte man “Raum” statt “Menge” sagen. Für Topologie-Fans: Das folgt sofort aus dem Satz von Tychonoff.)</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Im Spezialfall von Funktionen <code>[Bool] -&gt; Bool</code> bedeutet gleichmäßig stetig: Eine solche Funktion ist genau dann gleichmäßig stetig, wenn es eine Schranke <code>m</code> gibt, sodass die Funktion zur Berechnung ihres Ergebnisses nur die ersten <code>m</code> Bits der Folge benötigt (unabhängig von der speziellen Eingabefolge).</p></li>
<li><p><code>epsilon</code> ruft sich selbst rekursiv auf. Wenn <code>p</code> als Schranke <code>m</code> hat, dann hat das im rekursiven Aufruf verwendete Prädikat <code>(p . (False:))</code> als Schranke <code>m-1</code>. Also terminiert nach <code>m</code> rekursiven Aufrufen das Verfahren.</p></li>
</ol>
<p><strong>Und die Moral von der Geschicht</strong></p>
<p>In der Frage, ob Gleichheit von Funktionen vom Typ <code>A -&gt; Bool</code> entscheidbar ist, ist es nicht relevant, ob <code>A</code> endlich ist oder nicht. Tatsächlich entscheidend ist, ob <code>A</code> <em>kompakt</em> ist oder nicht.</p>
<ul>
<li>Endliche Typen sind kompakt.</li>
<li><code>[Bool]</code> ist kompakt.</li>
<li>Sind <code>A</code> und <code>B</code> kompakt, so auch der Produkttyp <code>(A,B)</code>.</li>
<li><code>Nat</code> und <code>Integer</code> sind nicht kompakt.</li>
<li>Der Datentyp der “lazy naturals”, welche auch <code>+infty</code> enthalten, ist kompakt.</li>
</ul>
<p><strong>Übungsaufgaben:</strong></p>
<ol style="list-style-type: decimal">
<li>Übertrage die Funktion <code>epsilon</code> – und damit auch <code>exists</code> und <code>forall</code>, auf den Fall von Funktionen <code>NAT -&gt; Bool</code> (statt <code>[Bool] -&gt; Bool</code>). Dabei soll <code>NAT</code> der Typ der “lazy naturals” sein, zum Beispiel definiert durch:</li>
</ol>
<p><code>data NAT = Zero | Succ NAT</code></p>
<p><code>infty = Succ infty</code></p>
<ol start="2" style="list-style-type: decimal">
<li>Definiere eine Typklasse <code>Compact</code> und implementiere Instanzen für <code>[Bool]</code> und <code>NAT</code> sowie eine generische Instanz <code>(Compact a, Compact b) =&gt;    Compact (a,b)</code>.</li>
</ol>
<p><strong>Diesen Text gibt es auch als <a href="https://github.com/iblech/vortrag-haskell/blob/master/impossible-programs.lhs">kompilierbares Literate Haskell</a>!</strong></p>
</article>
]]></description>
    <pubDate>Sun, 06 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-06-impossible-programs.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Der Curry Club auf dem 32c3</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-05-ankuendigung-curry-club-auf-dem-32c3.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Der Curry Club auf dem 32c3</h1>
    <div class="info">
      Gepostet am  5. Dez 15
      
          von Lukas Epple
      
    </div>
    
    
  </header>

  <div class="right">
<p><img width="300" src="/images/32C3_knot_lambda.png" /></p>
</div>
<p>Der Curry Club war auf dem 32. Chaos Communication Congress in Form <a href="https://events.ccc.de/congress/2015/wiki/Assembly:Curry_Club_Augsburg">einer Assembly</a> anwesend!</p>
<p>Die Folien unseres Vortrags “10 modern programming concepts which your favourite programming language is missing” (Tag 3, 15:00) sind <a href="/files/10-modern-concepts.pdf">online</a>.</p>
</article>
]]></description>
    <pubDate>Sat, 05 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-05-ankuendigung-curry-club-auf-dem-32c3.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Programm für das zehnte Treffen am 28. Januar 2016</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-04-zehntes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das zehnte Treffen am 28. Januar 2016</h1>
    <div class="info">
      Gepostet am  4. Dez 15
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Manuel Eberl hielt einen Vortrag zum Thema <em>Was ist die Quadratwurzel eines Baums?</em>. Darin ging es um ein paar unausgegorene, aber interessante Beobachtungen zu algebraischen Datentypen, analytischer Kombinatorik und Parametrizität.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/flD8Vh2Ghko" frameborder="0" allowfullscreen>
</iframe>
<p>Dr. Stefan Wehr erzählte von <a href="http://www.factisresearch.com/">factis research</a> vom praktischen Einsatz von Haskell in der Entwicklung von <a href="http://cp-med.com/">Checkpad Med</a>.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/XLJQQLKvGF0" frameborder="0" allowfullscreen>
</iframe>
<div class="right">
<p><img width="150" src="/images/pfds.jpg" /></p>
</div>
<p>Tim hielt einen Vortrag über <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">Purely Functional Data Structures</a>, genauer über Banker’s Queues.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/u14K7z365mY" frameborder="0" allowfullscreen>
</iframe>
<p>Makarius’ Vortrag wurde aufgrund der fortgeschrittenen Uhrzeit auf das nächste Treffen verschoben.</p>
</article>
]]></description>
    <pubDate>Fri, 04 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-04-zehntes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Neuntes Treffen am 3. Dezember 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-11-09-neuntes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Neuntes Treffen am 3. Dezember 2015</h1>
    <div class="info">
      Gepostet am  9. Nov 15
      
          von Lukas Epple
      
    </div>
    
    
  </header>

  <p>Ingo stellte die von Martín Escardó publizierten <a href="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">scheinbar unmöglichen funktionalen Programme</a> vor: Wie kann man in endlicher Zeit unendliche, ja sogar überabzählbar unendliche, Datenstrukturen absuchen?</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/F53aOAW9PBo" frameborder="0" allowfullscreen>
</iframe>
<p>Der Code vom Vortrag ist <a href="https://github.com/iblech/vortrag-haskell/blob/master/impossible-programs.lhs">auf Github</a>.</p>
<p>Profpatsch gab einen Einblick in die Haskell-Bibliothek <a href="https://hackage.haskell.org/package/brick">brick</a> geben, und in das Design-Schema, auf dem sie basiert und dem einige andere Bibliotheken folgen.</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/52UDaZDQ2to" frameborder="0" allowfullscreen>
</iframe>
</article>
]]></description>
    <pubDate>Mon, 09 Nov 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-11-09-neuntes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Achtes Treffen des Curry Clubs</title>
    <link>http://curry-club-augsburg.de/posts/2015-11-08-achtes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Achtes Treffen des Curry Clubs</h1>
    <div class="info">
      Gepostet am  8. Nov 15
      
          von Lars
      
    </div>
    
    <img src="/images/yes-we-kan.jpg" alt="Yes We Kan" />
    
    
  </header>

  <h1 id="über-scala-effekte-und-gopher">Über Scala, Effekte und Gopher</h1>
<p>Wie schon beim <a href="/posts/2015-07-02-drittes-treffen.html">dritten Treffen</a> war wieder Scala mit von der Partie.</p>
<h2 id="vorträge">Vorträge</h2>
<p>Lars verglich Scala mit Haskell und ML und zeigte, dass Scala nicht ein “schlechteres Haskell” oder ein “besseres ML” sei, sondern eine eigene Sprache mit eigenen Konzepten. Hauptpunkt war hier, dass in Scala viele Konzepte “first class” sind, wie z.B. Typklassen und Instanzen aus Haskell oder Module und Funktoren aus ML. Trotzdem erhält man dann einige Komplexität, mit der es dann – als Programmierer – diszipliniert umzugehen gilt. Der Vergleich von Programmiersprachen führt oft zu hintersinnigem Humor, aber auch Verzweiflung. Im Vortrag besonders erwähnt wurden: <a href="https://twitter.com/tihomirb/status/577624701767319552">Scala vs. Haskell</a> und <a href="https://twitter.com/srpablo/status/342341342694883329">Haskell vs. SML</a> – wobei bei “SML” viele Leute nur an das tatsächlich seit über 15 Jahren untote SML/NJ denken, nicht aber an das wesentlich frischere Poly/ML oder gar die Isabelle/ML-Umgebung. Teile des Vortrags können von einer vorherigen Iteration <a href="https://speakerdeck.com/larsrh/what-haskell-can-learn-from-scala">nachgelesen</a> bzw. <a href="https://skillsmatter.com/skillscasts/6592-what-haskell-can-learn-from-scala">nachgehört</a> werden.</p>
<p>Ingo gab eine kleine Einführung in Effektsysteme über freie Funktoren und freie Monaden. In diesem Vortrag der Reihe “What the Kmett is a Monad” zeigte Ingo, wie man aus beliebigen Typkonstruktoren einen (freien) Funktor und aus beliebigen Funktoren eine (freie) Monade machen kann. Als Anwendungszweck stellte er vor, wie man Effekte als einfachen Datentyp modelliert und aus diesem dann “für lau” eine passende Monade erhält, welche Programm mit diesen Effekten modellieren kann. Anschließend kann man dann dieses Programm interpretieren und so zum Beispiel nach IO, aber auch nach andere Monaden, überführen. Schließlich zeigte er noch das aktuelle Werk von Oleg Kiselyov, womit man zum Einen bessere Performance bekommt, zum Anderen aber auch auf einfache Art und Weise verschiedene Effekte kombinieren und modular interpretieren kann.</p>
<p>Sternenseemann erzählte uns zunächst vom Gopher-Protokoll, was drei Jahre vor HTTP/1.0 standardisiert worden ist. Tatsächlich gibt es anscheinend auch noch aktive Gopher-Server, die allerdings verschiedene Erweiterungen des Protokolls benutzen. Das Protokoll selbst ist relativ einfach strukturiert. Als krönenden Abschluss zeigte er uns seine Serverimplementation in Haskell names “Spacecookie”. Eine entsprechende Spacecookie-Monade durfte natürlich nicht fehlen.</p>
<h2 id="diskussionen-sonstiges">Diskussionen &amp; Sonstiges</h2>
<p>Tim hat Curry-Club-Sticker mitgebracht. Auf einen vorherigen Twitter-Beitrag hin hat sich ein Programmierer aus Barcelona gemeldet, der auch gerne welche hätte. Freundlicherweise hat Tim ihm ein paar Exemplare geschickt. Der Curry Club Augsburg ist demzufolge <a href="https://twitter.com/jordi_aranda/status/662695479021555713">international bekannt</a>!</p>
<p>Lars wies während Ingos Vortrag, bei dem Kan-Erweiterungen vorkamen, auf den obligatorischen “Yes We Kan”-Witz hin, der auch <a href="https://skillsmatter.com/skillscasts/6733-transformers-handlers-in-disguise">während der Haskell eXchange fiel</a>.</p>
<p>Ingo setzte eine Belohnung aus: auf einen Beweis der Tatsache, dass die Listenmonade keine freie Monade ist.</p>
</article>
]]></description>
    <pubDate>Sun, 08 Nov 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-11-08-achtes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>

    </channel>
</rss>
