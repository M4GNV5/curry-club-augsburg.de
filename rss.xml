<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Curry Club Augsburg</title>
        <link>http://curry-club-augsburg.de</link>
        <description><![CDATA[Neuigkeiten vom Curry Club Augsburg]]></description>
        <atom:link href="http://curry-club-augsburg.de/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 09 Dec 2015 00:00:00 UT</lastBuildDate>
        <item>
    <title>Zweiter großer Haskell-Workshop des Curry Clubs Augsburg am 20. Dezember 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-09-zweiter-workshop.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Zweiter großer Haskell-Workshop des Curry Clubs Augsburg am 20. Dezember 2015</h1>
    <div class="info">
      Gepostet am  9. Dez 15
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <div class="right">
<p><a href="/files/haskellworkshop-plakat2.pdf"> <img width="300" src="/files/haskellworkshop-plakat2.png" /> </a></p>
</div>
<p>Liebe Freundinnen und Freunde der Sonne!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu der Fortsetzung unseres <strong>Haskell-Workshops</strong> ein. Diese findet am <strong>20. Dezember 2015</strong>, einem Sonntag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Wie beim ersten Mal ist die Teilnahme kostenlos.</p>
<p>Zielgruppe des Workshops sind alle Teilnehmer des ersten Workshops sowie Einsteiger auf allen Fortschrittslevels.</p>
<p>Mit den Teilnehmenden vom letzten Mal werden wir dort weitermachen, wo wir das letzte Mal aufgehört haben. Während es damals darum ging die Basics zu lernen, wollen wir dieses Mal auf folgende Fragen eingehen:</p>
<ul>
<li>Welche verwendungsfertige Funktionen gibt es in der Standardbibliothek und auf <a href="http://hackage.haskell.org/">Hackage</a>?</li>
<li>Wie strukturiere ich größere Haskell-Programme?</li>
<li>Wie kann ich sicherstellen, dass mein Code das tut, was er soll?</li>
<li>Ich programmiere liebend gerne Parser / Webseiten / numerische Simulationen / Benutzeroberflächen / 3D-Spiele / XYZ. Wie mache ich das in Haskell?</li>
</ul>
<p>Am Anfang werden wir Monaden wiederholen. Ingo hat dazu auch einen <a href="/posts/2015-10-27-monaden-in-haskell.html">eigenen Blog-Post</a> geschrieben. Ihr tut euch mit Monaden erheblich leichter, wenn ihr diesen Artikel vor dem Workshop liest! Falls ihr das letzte Mal nicht fertig geworden seid, dann ist das kein Problem. Dann könnt ihr einfach das <a href="https://github.com/curry-club-aux/haskell-workshop/raw/gh-pages/uebung.pdf">Übungsblatt</a> weiter bearbeiten und wir helfen euch dabei.</p>
<p>Für Neueinsteiger wird es eine eigene Gruppe geben. Teilnahmevoraussetzung für Neueinsteiger ist entweder Erfahrung mit einer beliebigen anderen Programmiersprache oder Vertrautheit mit mathematisch/abstraktem Denken.</p>
<p>Wer vorhat, am Workshop teilzunehmen, kann sich in ein <a href="https://ola.pads.ccc.de/haskell-workshop-2015b">Organisationspad</a> eintragen und dann am 20. Dezember mit dem eigenen Laptop ins OpenLab kommen. Bitte vorab die <a href="https://www.haskell.org/platform/">Haskell Platform</a> installieren, um auf dem Workshop Zeit zu sparen.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<!--more-->
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></description>
    <pubDate>Wed, 09 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-09-zweiter-workshop.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Scheinbar unmögliche Programme</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-06-impossible-programs.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Scheinbar unmögliche Programme</h1>
    <div class="info">
      Gepostet am  6. Dez 15
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span></code></pre></div>
<p>Mit <code>[Bool]</code> meinen wir den Typ der unendlichen 0/1-Folgen.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> p1, p2,<span class="ot"> p3 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> p1 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">3</span>
<span class="ot">&gt;</span> p2 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">4</span>
<span class="ot">&gt;</span> p3 xs <span class="fu">=</span> xs<span class="fu">!!</span>(<span class="dv">2</span><span class="fu">+</span><span class="dv">1</span>) <span class="fu">&amp;&amp;</span> (xs<span class="fu">!!</span><span class="dv">8</span> <span class="fu">||</span> not (xs<span class="fu">!!</span><span class="dv">8</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test1 <span class="fu">=</span> p1 <span class="fu">==</span> p2
<span class="ot">&gt;</span> test2 <span class="fu">=</span> p1 <span class="fu">==</span> p3</code></pre></div>
<p>Das liefert einen Fehler über eine fehlende <code>Eq</code>-Instanz, oder? Weit gefehlt! Beide Programme terminieren. <code>test1</code> hat den Wert <code>False</code>, <code>test2</code> hat den Wert <code>True</code>.</p>
<p>Das ist umso erstaunlicher, wenn man bedenkt, dass <code>[Bool]</code> <em>überabzahlbar unendlich groß ist</em>.</p>
<p><strong>Hintergrund: Abzählbarkeit und Überabzählbarkeit</strong></p>
<p>Eine Menge heißt genau dann <em>abzählbar</em>, wenn es eine unendliche Liste gibt, in der alle Elemente der Menge vorkommen.</p>
<p>Prototypbeispiel: Die Menge N der natürlichen Zahlen ist abzählbar.</p>
<pre><code>0, 1, 2, 3, 4, ...</code></pre>
<p>Die Menge Z der ganzen Zahlen ist ebenfalls abzählbar, insbesondere also genau so groß wie die Menge der natürlichen Zahlen:</p>
<pre><code>0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, ...</code></pre>
<p>Übungsaufgabe: Zeige, dass auch die Menge Q der rationalen Zahlen abzählbar ist.</p>
<p>Eine Menge heißt genau dann <em>überabzählbar</em>, wenn sie nicht abzählbar ist.</p>
<p>Beispiel (Cantor): Die Menge R der reellen Zahlen ist überabzählbar.</p>
<p>Oder: Die Menge [Bool] aller unendlichen 0/1-Folgen ist überabzählbar.</p>
<p>Beweis durch das Cantorsche Diagonalargument:</p>
<p>Keine Liste von 0/1-Folgen kann <em>alle</em> 0/1-Folgen enthalten. Denn wenn zum Beispiel folgende Liste gegeben ist:</p>
<pre>
01000101011011011...
11101011111101111...
10101010101010101...
11100011100010010...
10010101100100000...
11010101100100000...
.
.
.
</pre>
<p>Wenn man nun die Diagonale (von oben links nach unten rechts) durchgeht, und jeweils die Gegenziffer wählt, erhält man eine 0/1-Folge, die sicher nicht in der Liste vorkommt. Im Beispiel wäre das</p>
<pre>100110...</pre>
<p>Diese 0/1-Folge kann nicht das erste Element der Liste sein, denn sie unterscheidet sich vom ersten Element ja an der vordersten Stelle. Sie kann auch nicht das zweite Element der Liste sein, denn sie unterscheidet sich vom zweiten Element ja an der zweitvordersten Stelle. Und so weiter!</p>
<p><strong>Epsilon</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, d.h. falls es eine 0/1-Folge <code>xs</code> gibt, sodass <code>p xs</code>, dann soll <code>epsilon p</code> irgendeine 0/1-Folge sein, sodass <code>p (epsilon p)</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, dann kann <code>epsilon p</code> sein, was es möchte.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; epsilon ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> epsilon p <span class="fu">=</span> <span class="kw">if</span> p (<span class="dt">False</span> <span class="fu">:</span> xs)
<span class="ot">&gt;</span>     <span class="kw">then</span> <span class="dt">False</span> <span class="fu">:</span> xs
<span class="ot">&gt;</span>     <span class="kw">else</span> <span class="dt">True</span>  <span class="fu">:</span> epsilon (p <span class="fu">.</span> (<span class="dt">True</span><span class="fu">:</span>))
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon (p <span class="fu">.</span> (<span class="dt">False</span><span class="fu">:</span>))</code></pre></div>
<p>Etwas schneller geht es dank Lazyness so:</p>
<pre><code>epsilon :: ([Bool] -&gt; Bool) -&gt; [Bool]
epsilon p = h : epsilon (p . (h:))
    where
    h = not $ p (False : epsilon (p . (False:)))</code></pre>
<p>Wer es noch schneller möchte – sodass auch Code wie <code>epsilon $ \xs -&gt; xs !! (10^10)</code> funktioniert, kann sich den Code von Martín Escardó ansehen.</p>
<p><strong>exists</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, dann soll <code>exists p</code> ein Zeuge dieser Erfüllbarkeit sein (in einem Maybe verpackt), also eine 0/1-Folge <code>xs</code>, sodass <code>p xs</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, soll <code>exists p</code> <code>Nothing</code> sein.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; exists ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> exists p <span class="fu">=</span> <span class="kw">if</span> p xs <span class="kw">then</span> <span class="dt">Just</span> xs <span class="kw">else</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon p</code></pre></div>
<p><strong>forall</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p><code>forall p</code> soll dann und nur dann True sein, falls `<code>p auf jeder 0/1-Folge konstant</code>True` ist.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; forall ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> forall p <span class="fu">=</span> isNothing <span class="fu">$</span> exists (not <span class="fu">.</span> p)</code></pre></div>
<p>Punktfrei geht es auch:</p>
<p><code>forall = not . isJust . exists . (not .)</code></p>
<p><strong>Eq-Instanz für Funktionen [Bool] -&gt; Bool</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Eq</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="kw">where</span>
<span class="ot">&gt;</span>     f <span class="fu">==</span> g <span class="fu">=</span> forall <span class="fu">$</span> \xs <span class="ot">-&gt;</span> f xs <span class="fu">==</span> g xs
<span class="ot">&gt;</span>     <span class="co">-- &quot;zwei Prädikate sind genau dann gleich, wenn sie auf jedem Argument</span>
<span class="ot">&gt;</span>     <span class="co">-- gleich sind&quot;</span></code></pre></div>
<p><strong>Exkurs: Beispiel für eine unstetige Funktion</strong></p>
<p>Eine Funktion von R nach R ist genau dann stetig, wenn man ihren Graph zeichnen kann, ohne den Stift abzusetzen. Eine stetige Funktion darf also keine Sprungstellen besitzen.</p>
<pre>
f : R --> R

x |-> if x < 0 then -1 else if x == 0 then 0 else 1

</pre>
<p>Die Signumfunktion!</p>
<p>Sie ist aber nur definiert auf der Teilmenge</p>
<pre>{ x in R | x < 0 oder x = 0 oder x > 0 }.</pre>
<p>Konstruktiv kann man nicht zeigen, dass diese Teilmenge ganz R ist. Die Funktion ist also nicht als total nachweisbar.</p>
<p><strong>Wieso funktionieren die “scheinbar unmöglichen Programme”?</strong></p>
<ol style="list-style-type: decimal">
<li><p>In Haskell kann man nur stetige Funktionen implementieren. (Wie in manchen Schulen konstruktiver Mathematik auch.) Jede Funktion vom Typ <code>[Bool] -&gt; Bool</code> ist stetig.</p></li>
<li><p>In der Topologie gibt es folgenden Satz: Jede stetige Funktion, deren Definitionsmenge kompakt ist, ist schon gleichmäßig stetig.</p></li>
</ol>
<p>Die Menge <code>[Bool]</code> ist kompakt. (Eigentlich sollte man “Raum” statt “Menge” sagen. Für Topologie-Fans: Das folgt sofort aus dem Satz von Tychonoff.)</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Im Spezialfall von Funktionen <code>[Bool] -&gt; Bool</code> bedeutet gleichmäßig stetig: Eine solche Funktion ist genau dann gleichmäßig stetig, wenn es eine Schranke <code>m</code> gibt, sodass die Funktion zur Berechnung ihres Ergebnisses nur die ersten <code>m</code> Bits der Folge benötigt (unabhängig von der speziellen Eingabefolge).</p></li>
<li><p><code>epsilon</code> ruft sich selbst rekursiv auf. Wenn <code>p</code> als Schranke <code>m</code> hat, dann hat das im rekursiven Aufruf verwendete Prädikat <code>(p . (False:))</code> als Schranke <code>m-1</code>. Also terminiert nach <code>m</code> rekursiven Aufrufen das Verfahren.</p></li>
</ol>
<p><strong>Und die Moral von der Geschicht</strong></p>
<p>In der Frage, ob Gleichheit von Funktionen vom Typ <code>A -&gt; Bool</code> entscheidbar ist, ist es nicht relevant, ob <code>A</code> endlich ist oder nicht. Tatsächlich entscheidend ist, ob <code>A</code> <em>kompakt</em> ist oder nicht.</p>
<ul>
<li>Endliche Typen sind kompakt.</li>
<li><code>[Bool]</code> ist kompakt.</li>
<li>Sind <code>A</code> und <code>B</code> kompakt, so auch der Produkttyp <code>(A,B)</code>.</li>
<li><code>Nat</code> und <code>Integer</code> sind nicht kompakt.</li>
<li>Der Datentyp der “lazy naturals”, welche auch <code>+infty</code> enthalten, ist kompakt.</li>
</ul>
<p><strong>Übungsaufgaben:</strong></p>
<ol style="list-style-type: decimal">
<li>Übertrage die Funktion <code>epsilon</code> – und damit auch <code>exists</code> und <code>forall</code>, auf den Fall von Funktionen <code>NAT -&gt; Bool</code> (statt <code>[Bool] -&gt; Bool</code>). Dabei soll <code>NAT</code> der Typ der “lazy naturals” sein, zum Beispiel definiert durch:</li>
</ol>
<p><code>data NAT = Zero | Succ NAT</code></p>
<p><code>infty = Succ infty</code></p>
<ol start="2" style="list-style-type: decimal">
<li>Definiere eine Typklasse <code>Compact</code> und implementiere Instanzen für <code>[Bool]</code> und <code>NAT</code> sowie eine generische Instanz <code>(Compact a, Compact b) =&gt;    Compact (a,b)</code>.</li>
</ol>
<p><strong>Diesen Text gibt es auch als <a href="https://github.com/iblech/vortrag-haskell/blob/master/impossible-programs.lhs">kompilierbares Literate Haskell</a>!</strong></p>
</article>
]]></description>
    <pubDate>Sun, 06 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-06-impossible-programs.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Der Curry Club auf dem 32c3</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-05-ankuendigung-curry-club-auf-dem-32c3.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Der Curry Club auf dem 32c3</h1>
    <div class="info">
      Gepostet am  5. Dez 15
      
          von Lukas Epple
      
    </div>
    
    
  </header>

  <p>Der Curry Club wird auf dem 32. Chaos Communication Congress in Form <a href="https://events.ccc.de/congress/2015/wiki/Assembly:Curry_Club_Augsburg">einer Assembly</a> sein! Wir haben schon begonnen, uns ein bisschen Programm für die vier Tage zu überlegen, die Planung läuft aktuell über die Mailingliste.</p>
</article>
]]></description>
    <pubDate>Sat, 05 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-05-ankuendigung-curry-club-auf-dem-32c3.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Programm für das zehnte Treffen am 21. Januar 2016</title>
    <link>http://curry-club-augsburg.de/posts/2015-12-04-zehntes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das zehnte Treffen am 21. Januar 2016</h1>
    <div class="info">
      Gepostet am  4. Dez 15
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Tim wird die Reihe über <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">Purely Functional Data Structures</a> mit einem Vortrag über Banker’s Queues einleiten.</p>
</article>
]]></description>
    <pubDate>Fri, 04 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-12-04-zehntes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Neuntes Treffen am 3. Dezember 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-11-09-neuntes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Neuntes Treffen am 3. Dezember 2015</h1>
    <div class="info">
      Gepostet am  9. Nov 15
      
          von Lukas Epple
      
    </div>
    
    
  </header>

  <p>Ingo stellte die von Martín Escardó publizierten <a href="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">scheinbar unmöglichen funktionalen Programme</a> vor: Wie kann man in endlicher Zeit unendliche, ja sogar überabzählbar unendliche, Datenstrukturen absuchen?</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/F53aOAW9PBo" frameborder="0" allowfullscreen>
</iframe>
<p>Der Code vom Vortrag ist <a href="https://github.com/iblech/vortrag-haskell/blob/master/impossible-programs.lhs">auf Github</a>.</p>
<p>Profpatsch gab einen Einblick in die Haskell-Bibliothek <a href="https://hackage.haskell.org/package/brick">brick</a> geben, und in das Design-Schema, auf dem sie basiert und dem einige andere Bibliotheken folgen.</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/52UDaZDQ2to" frameborder="0" allowfullscreen>
</iframe>
</article>
]]></description>
    <pubDate>Mon, 09 Nov 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-11-09-neuntes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Achtes Treffen des Curry Clubs</title>
    <link>http://curry-club-augsburg.de/posts/2015-11-08-achtes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Achtes Treffen des Curry Clubs</h1>
    <div class="info">
      Gepostet am  8. Nov 15
      
          von Lars
      
    </div>
    
    <img src="/images/yes-we-kan.jpg" alt="Yes We Kan" />
    
    
  </header>

  <h1 id="über-scala-effekte-und-gopher">Über Scala, Effekte und Gopher</h1>
<p>Wie schon beim <a href="/posts/2015-07-02-drittes-treffen.html">dritten Treffen</a> war wieder Scala mit von der Partie.</p>
<h2 id="vorträge">Vorträge</h2>
<p>Lars verglich Scala mit Haskell und ML und zeigte, dass Scala nicht ein “schlechteres Haskell” oder ein “besseres ML” sei, sondern eine eigene Sprache mit eigenen Konzepten. Hauptpunkt war hier, dass in Scala viele Konzepte “first class” sind, wie z.B. Typklassen und Instanzen aus Haskell oder Module und Funktoren aus ML. Trotzdem erhält man dann einige Komplexität, mit der es dann – als Programmierer – diszipliniert umzugehen gilt. Der Vergleich von Programmiersprachen führt oft zu hintersinnigem Humor, aber auch Verzweiflung. Im Vortrag besonders erwähnt wurden: <a href="https://twitter.com/tihomirb/status/577624701767319552">Scala vs. Haskell</a> und <a href="https://twitter.com/srpablo/status/342341342694883329">Haskell vs. SML</a> – wobei bei “SML” viele Leute nur an das tatsächlich seit über 15 Jahren untote SML/NJ denken, nicht aber an das wesentlich frischere Poly/ML oder gar die Isabelle/ML-Umgebung. Teile des Vortrags können von einer vorherigen Iteration <a href="https://speakerdeck.com/larsrh/what-haskell-can-learn-from-scala">nachgelesen</a> bzw. <a href="https://skillsmatter.com/skillscasts/6592-what-haskell-can-learn-from-scala">nachgehört</a> werden.</p>
<p>Ingo gab eine kleine Einführung in Effektsysteme über freie Funktoren und freie Monaden. In diesem Vortrag der Reihe “What the Kmett is a Monad” zeigte Ingo, wie man aus beliebigen Typkonstruktoren einen (freien) Funktor und aus beliebigen Funktoren eine (freie) Monade machen kann. Als Anwendungszweck stellte er vor, wie man Effekte als einfachen Datentyp modelliert und aus diesem dann “für lau” eine passende Monade erhält, welche Programm mit diesen Effekten modellieren kann. Anschließend kann man dann dieses Programm interpretieren und so zum Beispiel nach IO, aber auch nach andere Monaden, überführen. Schließlich zeigte er noch das aktuelle Werk von Oleg Kiselyov, womit man zum Einen bessere Performance bekommt, zum Anderen aber auch auf einfache Art und Weise verschiedene Effekte kombinieren und modular interpretieren kann.</p>
<p>Sternenseemann erzählte uns zunächst vom Gopher-Protokoll, was drei Jahre vor HTTP/1.0 standardisiert worden ist. Tatsächlich gibt es anscheinend auch noch aktive Gopher-Server, die allerdings verschiedene Erweiterungen des Protokolls benutzen. Das Protokoll selbst ist relativ einfach strukturiert. Als krönenden Abschluss zeigte er uns seine Serverimplementation in Haskell names “Spacecookie”. Eine entsprechende Spacecookie-Monade durfte natürlich nicht fehlen.</p>
<h2 id="diskussionen-sonstiges">Diskussionen &amp; Sonstiges</h2>
<p>Tim hat Curry-Club-Sticker mitgebracht. Auf einen vorherigen Twitter-Beitrag hin hat sich ein Programmierer aus Barcelona gemeldet, der auch gerne welche hätte. Freundlicherweise hat Tim ihm ein paar Exemplare geschickt. Der Curry Club Augsburg ist demzufolge <a href="https://twitter.com/jordi_aranda/status/662695479021555713">international bekannt</a>!</p>
<p>Lars wies während Ingos Vortrag, bei dem Kan-Erweiterungen vorkamen, auf den obligatorischen “Yes We Kan”-Witz hin, der auch <a href="https://skillsmatter.com/skillscasts/6733-transformers-handlers-in-disguise">während der Haskell eXchange fiel</a>.</p>
<p>Ingo setzte eine Belohnung aus: auf einen Beweis der Tatsache, dass die Listenmonade keine freie Monade ist.</p>
</article>
]]></description>
    <pubDate>Sun, 08 Nov 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-11-08-achtes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Monaden in Haskell (Nachtrag zum Haskell-Workshop)</title>
    <link>http://curry-club-augsburg.de/posts/2015-10-27-monaden-in-haskell.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Monaden in Haskell (Nachtrag zum Haskell-Workshop)</h1>
    <div class="info">
      Gepostet am 27. Okt 15
      
          von Ingo Blechschmidt
      
    </div>
    
    <img src="/images/a-monad-is-just.jpeg" alt="Eine Monade ist nichts anderes als ein Monoidobjekt in einer Kategorie von Endofunktoren" />
    
    
    <div class="attribution"><p><a href="http://wadler.blogspot.de/2012/12/tech-mesh-2012.html">Bodil Stokke und Philip Wadler auf der Tech Mesh 2012</a></p></div>
    
  </header>

  <p>Dieser kurze Artikel soll als Nachtrag zum Haskell-Workshop kurz umreißen, wie <em>monadische Ein- und Ausgabe</em> in Haskell funktioniert. TL;DR:</p>
<ul>
<li><p>Ein Wert vom Typ <code>IO a</code> ist eine Beschreibung einer IO-Aktion, welche durch die Laufzeitumgebung ausgeführt werden könnte (und dabei dann irgendwelche Nebenwirkungen verursachen und schließlich einen Wert vom Typ <code>a</code> produzieren würde).</p></li>
<li><p>Der Sinn eines Haskell-Programms besteht darin, die Beschreibung einer IO-Aktion <code>main</code> festzulegen. Diese wird dann von der Laufzeitumgebung ausgeführt. Andere Beschreibungen werden nicht ausgeführt.</p></li>
<li><p>Beschreibungen von IO-Aktionen kann man mit <code>&gt;&gt;</code> und <code>&gt;&gt;=</code> bzw. der do-Notation miteinander kombinieren. Der Operator <code>&gt;&gt;</code> ist wie das Zeilenende-Semikolon in anderen Sprachen.</p></li>
<li><p>Wenn man nur veränderlichen Zustand möchte, benötigt man nicht die IO-Monade. Man muss nur Zustand per Hand durchfädeln – oder die praktische Abstraktion durch die State-Monade nutzen.</p></li>
</ul>
<h1 id="das-problem-unverträglichkeit-mit-referenzieller-transparenz">Das Problem: Unverträglichkeit mit referenzieller Transparenz</h1>
<p>In vielen Programmiersprachen gibt es eine Funktion wie <code>readFile :: FilePath -&gt; String</code>, die eine Datei einliest und ihren Inhalt zurückgibt. <em>Eine solche Funktion kann es in Haskell nicht geben,</em> denn in Haskell gilt das Prinzip der <em>referenziellen Transparenz</em>: Wie in der Mathematik müssen Funktionen bei gleichen Eingaben gleiche Ausgaben produzieren. Der Rückgabewert von <code>readFile &quot;foo.txt&quot;</code> hängt aber vom aktuellen Inhalt der Datei <code>foo.txt</code> ab.</p>
<p>In Haskell schätzt man das Prinzip der referenziellen Transparenz sehr. Denn es ermöglicht es, Code rein lokal zu verstehen und leicht umzustrukturieren. Immer, wenn man irgendwo im Code an zwei Stellen denselben Teilausdruck erspäht, kann man diesen durch eine mit <code>let ... in ...</code> oder <code>where ...</code> eingeführte Variable ersetzen. Ohne referenzielle Transparenz geht das nicht:</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># Folgender Code ...</span>
say foo();
say foo();

<span class="co"># ... macht im Allgemeinen etwas anderes als dieser hier:</span>
<span class="kw">my</span> <span class="dt">$x</span> = foo();
say <span class="dt">$x</span>;
say <span class="dt">$x</span>;</code></pre></div>
<p>Denn <code>foo()</code> könnte Nebenwirkungen auslösen, die dann nur ein einziges Mal statt zwei Male ausgeführt werden (zum Beispiel, etwas auf Twitter zu posten), oder auf veränderlichem Zustand basieren (zum Beispiel der Anzahl Nanosekunden seit Programmstart).</p>
<p>Wie also kann man den Wunsch nach referenzieller Transparenz mit der Notwendigkeit, Ein- und Ausgabe zu betreiben, vereinbaren?</p>
<h1 id="die-lösung-monadische-ein--und-ausgabe">Die Lösung: Monadische Ein- und Ausgabe</h1>
<p>In Haskell ist man – nach einigen suboptimalen Lösungen und Irrwegen – auf das Konzept der <em>monadischen Ein- und Ausgabe</em> gestoßen, das das Problem vollumfänglich löst. Dieses hat elegante mathematische Hintergründe, die man für die Anwendung nicht kennen muss. So sieht ein Programm aus, das den ausführenden Lambdroiden freundlich grüßt:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    putStr <span class="st">&quot;Hallo! Was ist dein Name? &quot;</span>
    name <span class="ot">&lt;-</span> getLine
    putStr <span class="st">&quot;Das ist ein schöner Name. So lautet er rückwärts: &quot;</span>
    putStrLn (reverse name)</code></pre></div>
<p>Die beteiligten Typen sind <code>getLine :: IO String</code>, <code>putStr :: String -&gt; IO ()</code> und <code>putStrLn :: String -&gt; IO ()</code>. Die Konstante <code>main</code> hat den Typ <code>main :: IO ()</code>.</p>
<p>Was passiert hier? Es bleibt dabei, dass Haskell-Funktionen keine Nebenwirkungen wie Interaktion mit dem Terminal verursachen können. Haskell-Funktionen können allerdings durchaus IO-Aktionen <em>theoretisch beschreiben</em>. Der Sinn eines Haskell-Programms besteht in diesem Bild darin, eine bestimmte IO-Aktion zu beschreiben – die mit dem Namen <code>main</code>. Diese wird dann vom Laufzeitsystem ausgeführt.</p>
<p>Genau wie ein Wert vom Typ <code>Tree a</code> ein Baum ist, dessen Blätter vom Typ <code>a</code> sind, ist ein Wert vom Typ <code>IO a</code> eine Beschreibung einer IO-Aktion, die prinzipiell vom Laufzeitsystem ausgeführt werden könnte, dabei irgendwelche Nebenwirkungen verursachen und schließlich einen Wert vom Typ <code>a</code> produzieren würde. Solche Beschreibungen sind “first class values”, sie können manipuliert und in Datenstrukturen abgelegt werden, ohne dass sie bei Ablauf des Programms sofort ausgeführt werden würden. Nur eine einzige Beschreibung wird tatsächlich ausgeführt: die, die den Namen <code>main</code> trägt.</p>
<p>Das folgende Code-Beispiel soll diesen Punkt unterstreichen.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> seq (putStrLn <span class="st">&quot;abc&quot;</span>) (putStrLn <span class="st">&quot;def&quot;</span>)</code></pre></div>
<p>Die Funktion <code>seq</code> erzwingt die Auswertung ihres ersten Arguments – wenn <code>seq x y</code> ausgewertet wird, wird zunächst <code>x</code> ausgewertet und dann <code>y</code> zurückgegeben. Beispielsweise ist <code>seq (fib 10000) &quot;Curry&quot;</code> semantisch völlig identisch zur Konstante <code>&quot;Curry&quot;</code>, aber langsamer in der Ausführung.</p>
<p>Jedenfalls passiert beim Ablauf dieses Programms folgendes: Zunächst wird <code>putStrLn &quot;abc&quot;</code> ausgewertet. Das produziert eine Beschreibung einer IO-Aktion, die wenn ausgeführt <code>abc</code> auf dem Terminal ausgeben würde. Diese Beschreibung wird dann jedoch wieder verworfen. Schließlich produziert <code>putStrLn &quot;def&quot;</code> eine Beschreibung, die <code>def</code> ausgeben würde. Diese Beschreibung ist letztendlich der Wert von <code>main</code>, und diese Beschreibung wird vom Laufzeitsystem ausgeführt.</p>
<h1 id="konstruktion-komplexer-aktionsbeschreibungen">Konstruktion komplexer Aktionsbeschreibungen</h1>
<p>Vorimplementierte Funktionen wie <code>putStrLn :: String -&gt; IO ()</code> oder <code>readFile :: FilePath -&gt; IO String</code> produzieren gewisse primitive Beschreibungen von IO-Aktionen. Die allermeisten Programme werden sich aber mehrerer solcher primitiver Aktionen bedienen müssen. Es muss also eine Möglichkeit geben, mehrere Aktionsbeschreibungen zu einer komplexeren Beschreibung zu kombinieren – ganz so, wie etwa der Konstruktor <code>Fork</code> zwei Teilbäume zu einem großen zusammensetzt.</p>
<p>Dazu gibt es in der Tat mehrere Möglichkeiten.</p>
<ul>
<li><p>Der Operator <code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code> nimmt zwei Aktionsbeschreibungen. Wird die resultierende Beschreibung <code>m &gt;&gt; n</code> ausgeführt, so wird zunächst <code>m</code> ausgeführt (und ihr Ergebnis vom Typ <code>a</code> verworfen) und dann <code>n</code> ausgeführt.</p></li>
<li><p>In vielen Fällen möchte man die als zweites auszuführende Aktion vom Ergebnis der ersten abhängig machen. Dazu gibt es den Operator <code>(&gt;&gt;=) :: IO a -&gt; (a -&gt;   IO b) -&gt; IO b</code>. Die Aktionsbeschreibung <code>m &gt;&gt;= f</code> führt bei ihrer Ausführung dazu, dass zunächst <code>m</code> ausgeführt wird. Der dabei produzierte Wert <code>x</code> wird an die Funktion <code>f</code> übergeben, welche eine weitere Aktionsbeschreibung <code>f x</code> errechnet. Diese wird dann als zweites ausgeführt.</p></li>
</ul>
<p>Außerdem gibt es noch eine triviale Möglichkeit, eine Aktionsbeschreibung zu produzieren: Mit der Funktion <code>return :: a -&gt; IO a</code>, die (Achtung!) nichts mit dem gleichnamigen Schlüsselwort in vielen anderen Sprachen (zum vorzeitigen Verlassen einer Subroutine) zu tun hat. Vielmehr ist <code>return x</code> eine Aktionsbeschreibung, die bei ihrer Ausführung keinerlei Nebenwirkungen verursacht und dann den Wert <code>x</code> produziert.</p>
<p>Etwa kann man den Ausdruck <code>return x &gt;&gt; m</code> zu <code>m</code> vereinfachen. Beide Ausdrücke beschreiben genau dieselbe Aktion. Auch ist <code>return x &gt;&gt;= f</code> identisch zu <code>f x</code>.</p>
<p>Schließlich sei noch die <em>Funktorialität</em> von Aktionsbeschreibungen erwähnt, vermittelt durch die Funktion <code>fmap :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</code>. Ist <code>m :: IO a</code> eine Aktionsbeschreibung und ist <code>g :: a -&gt; b</code> eine beliebige Funktion, so beschreibt <code>fmap g m :: IO b</code> diejenige Aktion, die die Beschreibung <code>m</code> ausführt, deren Ergebnis <code>x :: a</code> an die Funktion <code>g</code> übergibt und schließlich den Wert <code>g x :: b</code> produziert.</p>
<p>Aus historischen Gründen kann man statt <code>fmap g m</code> auch <code>liftM g m</code> schreiben. Die beiden Ausdrücke beschreiben genau dieselbe IO-Aktion. Vielleicht hilft zum Verständnis die Identität <code>fmap g m == (m &gt;&gt;= (return . g))</code> (vielleicht aber auch nicht).</p>
<h1 id="die-do-notation">Die do-Notation</h1>
<p>Haskell erleichtert mit der <em>do-Notation</em> den Umgang mit Aktionsbeschreibungen ungemein. Sie ist angenehmer syntaktischer Zucker für die Operatoren <code>&gt;&gt;</code> und <code>&gt;&gt;=</code>. Das Eingangsbeispiel schreibt sich ohne do-Notation wie folgt:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    putStr <span class="st">&quot;Hallo! Was ist dein Name? &quot;</span> <span class="fu">&gt;&gt;</span>
        (getLine <span class="fu">&gt;&gt;=</span>
            (\name <span class="ot">-&gt;</span>
                putStr <span class="st">&quot;Das ist ein schöner Name. So lautet er rückwärts: &quot;</span> <span class="fu">&gt;&gt;</span>
                    putStrLn (reverse name)))</code></pre></div>
<p>Die Übersetzungsregeln lauten also:</p>
<ul>
<li><p>Zwei aufeinanderfolgende Anweisungen werden implizit mit <code>&gt;&gt;</code> miteinander verbunden.</p></li>
<li><p>Die Bindung des Produktionsergebnisses einer IO-Aktion mit <code>&lt;-</code> wird hinter den Kulissen in einen λ-Ausdruck und <code>&gt;&gt;=</code> umgesetzt.</p></li>
</ul>
<p>Solche Bindungen unterscheiden sich von den weiterhin möglichen Variablendefinitionen mit <code>let</code>. Ein längeres Programm könnte zum Beispiel so aussehen:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    putStr <span class="st">&quot;Was ist der Radius des Kreises? &quot;</span>
    antwort <span class="ot">&lt;-</span> getLine
    <span class="kw">let</span> radius <span class="fu">=</span> read antwort
        umfang <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> pi <span class="fu">*</span> radius
        n      <span class="fu">=</span> fib <span class="dv">42</span>
    putStrLn (<span class="st">&quot;Dann ist der Umfang: &quot;</span> <span class="fu">++</span> show umfang)
    putStrLn (<span class="st">&quot;Und die 42-te Fibonacci-Zahl ist: &quot;</span> <span class="fu">++</span> show n)</code></pre></div>
<p>Das sonst bei <code>let</code> benötigte Schlüsselwort <code>in</code> kann man bei der <code>do</code>-Notation weglassen.</p>
<h1 id="referenzielle-transparenz-ist-bewahrt">Referenzielle Transparenz ist bewahrt</h1>
<p>Der folgende Code gibt zwei Ausgaben aus:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn (show (fib <span class="dv">42</span>))
    putStrLn (show (fib <span class="dv">42</span>))</code></pre></div>
<p>Wenn man von Optimierungen des Compilers absieht, wird dabei die Aktionsbeschreibung <code>putStrLn (show (fib 42))</code> zwei Mal berechnet. Wenn man möchte, kann man den Code wie folgt umstrukturieren.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> m <span class="fu">=</span> putStrLn (show (fib <span class="dv">42</span>))
    m
    m

<span class="co">-- Alternativ ohne do-Notation:</span>
main <span class="fu">=</span> m <span class="fu">&gt;&gt;</span> m <span class="kw">where</span> m <span class="fu">=</span> putStrLn (show (fib <span class="dv">42</span>))</code></pre></div>
<p>Hier wird die Aktionsbeschreibung nur noch einmal berechnet, allerdings immer noch zwei Male ausgeführt.</p>
<h1 id="eigene-kontrollstrukturen">Eigene Kontrollstrukturen</h1>
<p>Dadurch, dass Aktionsbeschreibungen “first class values” sind, kann man leicht eigene Kontrollstrukturen definieren. Das Modul <code>Control.Monad</code> exportiert etwa folgende:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- `forever m` beschreibt eine unendliche Wiederholung von `m`.</span>
<span class="ot">forever ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
forever m <span class="fu">=</span> m <span class="fu">&gt;&gt;</span> forever m

<span class="co">-- `replicateM i m` beschreibt eine Aktion, die wenn ausgeführt</span>
<span class="co">-- die gegebene Beschreibung `m` `i` Mal ausführt und die dabei</span>
<span class="co">-- produzierten Ergebnisse in einer Liste sammelt.</span>
<span class="ot">replicateM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]
replicateM <span class="dv">0</span> _ <span class="fu">=</span> return []
replicateM i m <span class="fu">=</span> <span class="kw">do</span>
    x  <span class="ot">&lt;-</span> m
    xs <span class="ot">&lt;-</span> replicate (i<span class="fu">-</span><span class="dv">1</span>) m
    return (x<span class="fu">:</span>xs)

<span class="co">-- Was macht wohl diese Funktion?</span>
<span class="ot">forM ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> [b]
forM []     _ <span class="fu">=</span> return []
forM (x<span class="fu">:</span>xs) f <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<h1 id="eine-falle-im-umgang-mit-return">Eine Falle im Umgang mit <code>return</code></h1>
<p>Folgender Code enthält einen Typfehler:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    eman <span class="ot">&lt;-</span> revertierer
    putStrLn eman

revertierer <span class="fu">=</span> <span class="kw">do</span>
    name <span class="ot">&lt;-</span> getLine
    reverse name</code></pre></div>
<p>Das Problem liegt in der Zeile <code>reverse name</code>. Verwendet man die do-Notation, so muss (bis auf reine Anteile mit <code>let</code>) jede Zeile eine Aktionsbeschreibung sein, schließlich werden diese Beschreibungen dann hinter den Kulissen mit <code>&gt;&gt;</code> bzw. <code>&gt;&gt;=</code> zu einer großen kombiniert. Der Ausdruck <code>reverse name</code> ist allerdings eine einfache Liste, keine Aktionsbeschreibung. Abhilfe schafft die Verwendung von <code>return</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    eman <span class="ot">&lt;-</span> revertierer
    putStrLn eman

revertierer <span class="fu">=</span> <span class="kw">do</span>
    name <span class="ot">&lt;-</span> getLine
    return (reverse name)</code></pre></div>
<p>Idiomatischer würde man das Programm übrigens wie folgt schreiben.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main        <span class="fu">=</span> revertierer <span class="fu">&gt;&gt;=</span> putStrLn
revertierer <span class="fu">=</span> fmap reverse getLine</code></pre></div>
<h1 id="die-state-monade">Die State-Monade</h1>
<p>In Haskell gibt es keine veränderlichen Variablen. Man kann sie allerdings emulieren: Eine Funktion, die eigentlich eine gewisse Variable verändern möchte, kann den neuen Wert einfach an den Aufrufer zurückgeben. Dieser muss den neuen Wert dann bei weiteren Funktionsaufrufen berücksichtigen. Konkret kann das zum Beispiel so aussehen:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f1 ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> (<span class="dt">A</span>,<span class="dt">S</span>)
<span class="ot">f2 ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">A</span> <span class="ot">-&gt;</span> (<span class="dt">B</span>,<span class="dt">S</span>)
<span class="ot">f3 ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">B</span> <span class="ot">-&gt;</span> (<span class="dt">C</span>,<span class="dt">S</span>)

<span class="ot">f ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> (<span class="dt">C</span>,<span class="dt">S</span>)
f s <span class="fu">=</span>
    <span class="kw">let</span> (x,s&#39;)   <span class="fu">=</span> f1 s
        (y,s&#39;&#39;)  <span class="fu">=</span> f2 s&#39;  x
        (z,s&#39;&#39;&#39;) <span class="fu">=</span> f3 s&#39;&#39; y
    <span class="kw">in</span>  (z,s&#39;&#39;&#39;)</code></pre></div>
<p>Durch dieses manuelle Durchfädeln des Zustands kann man veränderliche Variablen in Haskell nachbauen. Schön ist das allerdings nicht! Und fehleranfällig obendrein. Der Compiler kann uns nämlich nicht davor schützen, die vielen Zwischenzustände zu verwechseln, also zum Beispiel <code>f3 s' y</code> statt <code>f3 s'' y</code> zu schreiben.</p>
<p>Abhilfe schafft die <em>State-Monade</em>. Folgender Code ist viel übersichtlicher:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f1 ::</span> <span class="dt">State</span> <span class="dt">S</span> <span class="dt">A</span>
<span class="ot">f2 ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">S</span> <span class="dt">B</span>
<span class="ot">f3 ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">S</span> <span class="dt">C</span>

<span class="ot">f ::</span> <span class="dt">State</span> <span class="dt">S</span> <span class="dt">C</span>
f <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> f1
    y <span class="ot">&lt;-</span> f2 x
    z <span class="ot">&lt;-</span> f3 y
    return z
<span class="co">-- oder kürzer: f = f1 &gt;&gt;= f2 &gt;&gt;= f3</span></code></pre></div>
<p>Einen Wert vom Typ <code>State s a</code> kann man sich analog zum IO-Fall als eine Beschreibung einer Aktion vorstellen: eine, die unter Zugriff und potenzieller Veränderung eines Zustands vom Typ <code>s</code> einen Wert vom Typ <code>a</code> produziert.</p>
<p>Primitive State-Aktionsbeschreibungen sind <code>put :: s -&gt; State s ()</code> zum Setzen des Zustands und <code>get :: State s s</code> zum Auslesen.</p>
<p>Mit der Funktion <code>runState :: State s a -&gt; s -&gt; (a,s)</code> kann man eine solche Beschreibung ausführen, wenn man einen initialen Wert des Zustands vorgibt. Das ist ein Unterschied zur IO-Monade: Nur das Laufzeitsystem ist in der Lage, eine Beschreibung einer IO-Aktion auszuführen. State-Aktionen können dagegen Haskell-intern ausgeführt werden.</p>
<p>Übrigens kommt es in der täglichen Praxis mit Haskell nicht besonders häufig vor, dass man veränderliche Variablen benötigen würde. Fast immer ist eine Alternativlösung ohne veränderliche Variablen eleganter und wartbarer. Falls man imperativ geprägt ist, lohnt es sich daher, etwas Mühe zu investieren, um zustandslose Implementierungen zu finden.</p>
<h1 id="weitere-monaden">Weitere Monaden</h1>
<p>Aus der Not wurde eine Tugend: Nachdem die Nützlichkeit des monadischen Ansatzes für Ein- und Ausgabe erkannt wurde, hat man viele weitere nützliche Monaden entdeckt und entworfen.</p>
<ul>
<li>State (veränderlicher Zustand)</li>
<li>Parser (Parsen von Text, <a href="/posts/2015-05-03-wir-bauen-einen-parserkombinator.html#beispiel-parsen-von-s-expressions">Beispiel: S-Ausdrücke</a>)</li>
<li>Maybe (Behandlung von Fehlerfällen, Vermeidung von “or else”-Kaskaden)</li>
<li>Reader (vererbende Umgebung, globale Konfigurationswerte)</li>
<li>Writer (Logging)</li>
<li>Listen (Nichtdeterminismus und Logikprogrammierung, <a href="https://github.com/iblech/mathezirkel-kurs/blob/master/thema17-haskell/magic.hs">Beispiel: magische Quadrate</a>)</li>
<li>Cont (Continuations, Beeinflussung des Kontrollflusses)</li>
</ul>
<p>Alle Monaden zeichnen sich dadurch aus, dass sie über Operatoren <code>&gt;&gt;=</code> und <code>return</code> sowie <code>fmap</code> verfügen. Es gibt eine Typklasse <code>Monad</code>, der alle Monaden angehören. Ihre Definition lautet:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)

<span class="kw">class</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">    (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>Gelegentlich kann man sogar <em>polymorph in der Monade</em> programmieren. Etwa ergeben die oben erwähnten Kontrollstrukturen <code>forever</code>, <code>replicateM</code> und <code>forM</code> nicht nur im Spezialfall der IO-Monade Sinn, sondern auch bei jeder anderen Monade.</p>
<h1 id="wie-gehts-weiter">Wie geht’s weiter?</h1>
<p>Zunächst gibt es <a href="https://github.com/curry-club-aux/haskell-workshop/raw/gh-pages/uebung.pdf">unsere Übungsaufgaben vom Workshop</a> zu Monaden. Ferner gibt es im Internet <a href="https://wiki.haskell.org/Monad_tutorials_timeline">zahlreiche Einführungen</a> in die Welt der Monaden. Außerdem gibt es Artikel über die <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Monad Tutorial Fallacy</a>. Sobald man Monaden verstanden hat, verliert man instantan die Fähigkeit, sie verständlich zu erklären.</p>
<p>Wer fortgeschritten ist und verstehen möchte, was Monaden mit Monoiden zu tun haben, sei ein <a href="/files/freie-monaden.pdf">Foliensatz</a> von einem der Treffen des Curry Clubs empfohlen. Für alle lesenswert ist aber auf jeden Fall ein Artikel des großartigen Dan “sigfpe” Piponi: <a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You could have invented monads! (And maybe you already have.)</a></p>
</article>
]]></description>
    <pubDate>Tue, 27 Oct 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-10-27-monaden-in-haskell.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Einladung zum großen Haskell-Workshop des Curry Clubs Augsburg am 25. Oktober 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-10-14-einladung-haskell-workshop.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Einladung zum großen Haskell-Workshop des Curry Clubs Augsburg am 25. Oktober 2015</h1>
    <div class="info">
      Gepostet am 14. Okt 15
      
          von Ingo Blechschmidt
      
    </div>
    
    <img src="/images/learn-you-a-haskell-for-great-good.png" alt="Learn you a Haskell for great good" />
    
    
    <div class="attribution"><p><a href="http://learnyouahaskell.com/">LearnYouAHaskell</a> (CC BY-NC-SA)</p></div>
    
  </header>

  <p>Liebe Freundinnen und Freunde von verallgemeinertem abstrakten Nonsens!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu einem <strong>Haskell-Workshop für Neulinge</strong> ein. Dieser findet am <strong>25. Oktober 2015</strong>, einem Sonntag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Die Teilnahme ist kostenlos.</p>
<p>Haskell ist eine wunderschöne Sprache, in der man nicht das “wie” spezifiziert, sondern das “was”. Ein Haskell-Programm besteht – anders als bei allen gewöhnlichen Programmiersprachen – nicht aus einer Folge von Anweisungen, welche von oben nach unten ausgeführt (und nur durch Kontrollstrukturen oder Subroutinen aufgelockert) werden. Haskell-Code kann man fast beliebig in seiner Reihenfolge permutieren, ohne die Bedeutung zu verändern. Ein ausführlicher Werbetext steht unten.</p>
<p>Zielgruppe des Workshops sind in erster Linie völlige Haskell-Neulinge. Teilnahmevoraussetzung ist entweder Erfahrung mit einer beliebigen anderen Programmiersprache oder Vertrautheit mit mathematisch/abstraktem Denken. Wer Haskell schon etwas besser kennt, wird auch auf seine Kosten kommen: Dann gibt es parallel zum Hauptprogramm eine Einführung und Übungsaufgaben zur Standardbibliothek. Haskell-Profis sollten keinesfalls als Teilnehmende mitmachen, sondern lieber das Betreuendenteam verstärken.</p>
<p>Wer vorhat, am Workshop teilzunehmen, kann sich in ein <a href="https://ola.pads.ccc.de/haskell-workshop-2015">Organisationspad</a> eintragen und dann am 25. Oktober mit dem eigenen Laptop ins OpenLab kommen. Bitte vorab die <a href="https://www.haskell.org/platform/">Haskell Platform</a> installieren, um auf dem Workshop Zeit zu sparen.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<p><strong>Update:</strong> <a href="https://github.com/curry-club-aux/haskell-workshop/raw/gh-pages/uebung.pdf">Die Übungsaufgaben vom Workshop sind online.</a></p>
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></description>
    <pubDate>Wed, 14 Oct 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-10-14-einladung-haskell-workshop.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Programm für das achte Treffen am 5. November 2015</title>
    <link>http://curry-club-augsburg.de/posts/2015-09-19-ankuendigung-achtes-treffen.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Programm für das achte Treffen am 5. November 2015</h1>
    <div class="info">
      Gepostet am 19. Sep 15
      
          von Tim Baumann, Profpatsch
      
    </div>
    
    
  </header>

  <div class="portrait">
<p><img src="/images/lars_hupel.jpg" title="Lars Hupel Porträt" alt="" /> <a href="https://github.com/larsrh">Lars Hupel</a> gibt eine Einführung in Scala und vergleicht die Sprache mit Haskell und ML. Der Vortrag ist angelehnt an seine Präsentation “What Haskell can learn from Scala” vom <a href="https://skillsmatter.com/conferences/7069-haskell-exchange-2015#program">diesjährigen Haskell eXchange</a>.</p>
</div>
<p><a href="https://github.com/lukasepple">Sternenseemann</a> erzählt uns von Gopher und seiner <a href="https://github.com/lukasepple/spacecookie">Serverimplementation in Haskell, „Spacecookie“</a>. Die Folien sind <a href="/files/gopher-server.pdf">hier zu finden</a>.</p>
<p><a href="https://github.com/iblech">Ingo</a> gibt eine Nano-Einführung in <em>Effektsysteme</em> über <em>freie Funktoren</em> und <em>freie Monaden</em>. Dabei streifen wir das <a href="http://apfelmus.nfshost.com/articles/operational-monad.html">operational-Paket</a> von Heinrich Apfelmus und den <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">neuesten Aufsatz von Oleg</a>. Das setzt die Reihe <em>What the Kmett is a monad?</em> fort. Themenbezogene Fragestellungen sind: Wie kann man die spezifischen Fähigkeiten zweier Monaden miteinander kombinieren? Wie kann man eine Monade durch Angabe einer gewünschten operationellen Semantik konstruieren? Grundlagen aus dem <a href="/files/freie-monaden.pdf">früheren Vortrag</a> sind dafür hilfreich, aber nicht notwendig. <a href="/files/effektsysteme.pdf">Folien</a>, <a href="https://github.com/iblech/vortrag-haskell/blob/master/effektsysteme.hs">Code</a>.</p>
<p>Außerdem: Es werden coole Sticker für euer Notebook verschenkt!</p>
<div class="figure">
<img src="/images/sticker-ausgedruckt.jpg" title="Frisch gedruckte Sticker" alt="" />

</div>
</article>
]]></description>
    <pubDate>Sat, 19 Sep 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-09-19-ankuendigung-achtes-treffen.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>
<item>
    <title>Hitliste der Talks von der ICFP</title>
    <link>http://curry-club-augsburg.de/posts/2015-09-16-hitliste-der-ICFP-talks.html</link>
    <description><![CDATA[<article>
  <header>
    <h1>Hitliste der Talks von der ICFP</h1>
    <div class="info">
      Gepostet am 16. Sep 15
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> hat die offizielle Empfehlungsliste des Curry Clubs für Talks von der diesjährigen <a href="http://www.icfpconference.org/">ICFP</a> erstellt. Wir wünschen angenehme Stunden der funktionalen Weiterbildung!</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=ga83zOo95bs">The State of GHC</a> von Simon Peyton Jones<br />
 Ein Ausblick auf GHC 8.0. Pflichtvideo. (Achtung: Comic Sans in gelb auf blau.)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=ZEUTndOzrvw">The State of GHCJS</a> von Luite Stegeman<br />
 Kurzzusammenfassung: GHCJS ist mit GHC 7.10.2 endlich einfach zu installieren. Es gibt eine neue Version der GHCJS-Standardbibliothek. Es steht einem Praxiseinsatz von GHCJS nichts mehr im Wege!</p></li>
<li><p><a href="https://www.youtube.com/watch?v=hI0ajVy2xEk">Practical Probabilistic Programming with Monads</a> von Adam Scibior<br />
 Eine DSL, mit der man bayesische Inferenz betreiben kann. (sehr interessant)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=AFSLMTgoClI">GADTs Meet Their Match</a> von George Karachalias<br />
 Wenn man in Haskell eine Funktion “a -&gt; b” definiert, dann überprüft GHC, ob man mit der Definition jede mögliche Eingabe abgedeckt hat. Das funktioniert aber noch nicht so gut, wenn a ein GADT ist. Der Vortrag beschreibt einen Algorithmus, der dieses Problem löst.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=PrDSxnO29d0">Look Ma, No Signatures!</a> von Edward Z. Yang<br />
 Wie bringt man GHC bei, rekursiv voneinander abhängige Module zu kompilieren? (sehr unterhaltsam)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=T88TDS7L5DY">The Unreasonable Effectiveness of Lenses for Business Applications</a> von Edward Kmett<br />
 Ein Lens-Vortrag vom geliebten Propheten höchstpersönlich. Außerdem: Sonderpreis für den besten Vortragstitel</p></li>
<li><p><a href="https://www.youtube.com/watch?v=WajfYdqCeAM">Practical Principled FRP</a> von Atze van der Ploeg<br />
 Untertitel: Forget the past, change the future! FRPNow! Ein neuer Ansatz für Functional Reactive Programming.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NVEgyJCTee4">The History of Standard ML: Ideas, Principles, Culture</a> von David MacQueen<br />
 Von Makarius empfohlen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=RRmb2RtU0hU">Stack</a> von Emanual Borsboom<br />
 Über die neue <code>cabal</code>-Alternative. Ich habe sehr gute Erfahrungen mit Stack gemacht. Im Gegensatz zu Cabal hatte ich mit Stack noch nie Probleme damit, dass verschiedene Pakete unterschiedliche Versionen von Dependencies vorausgesetzt haben. Es verwendet dazu eine kuratierte Datenbank von Paketen und Schnappschüssen von miteinander verträglichen Versionen von diesen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=lNSfVpKEnnI">Which simple Types have a unique Inhabitant?</a> von Gabriel Scherer<br />
 Es wird ein Algorithmus skizziert, der diese Frage wird im Setting des einfach typisierten Lambda-Kalküls beantwortet. In komplexeren Typsystemen ist diese Frage unentscheidbar. Ein Algorithmus, der diese Frage in vielen Fällen beantwortet kann aber trotzdem hilfreich für Programmierer sein.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=W6a36RoFeNw">Future of Haskell: Dependent types</a> von Richard Eisenberg<br />
 Es gibt den Plan, GHC abhängige Typen beizubringen. Dieser Vortrag stellt kurz (in ca 5min) vor, was damit möglich sein wird. Danach gibt es eine lange Diskussion.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=guMLPr6eBLo">The Remote Monad Design Pattern</a> von Andy Gill<br />
 Wie man durch Bündeln von Kommandos mit möglichst wenigen Netzwerkzugriffen andere Geräte, wie z.B. Toaster steuert.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=oAz8AEf7WDA">Diagrams: A Functional EDSL for Vector Graphics</a> von Ryan Yates und Brent Yorgey<br />
 Über die supercoole Bibliothek <a href="http://projects.haskell.org/diagrams/"><code>diagrams</code></a>, mit der man Vektorgraphiken mit Haskell zeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=D1rm5SnvmKE">Guilt Free Ivory</a> von Galois<br />
 Design einer Haskell-DSL, die sicheren C-Code für eingebettete Systeme erzeugt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NBBQoX1EWCY">Monadic Effects</a> von Niki Vazou und Daan Leijen<br />
 Beschreibt die Sprache Koka, die nach JavaScript kompiliert und ein Effektsystem besitzt. Es ist dabei möglich, eigene Effekte zu implementieren, indem man einfach eine Monadeninstanz schreibt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=nBaRKI5q-DI">Dependent Types for Real time Constraints</a> von William Blair<br />
 Für Real-Time-Systeme (z.B. der Flugkontrolle in einem Flugzeug) gibt es synchrone Programmiersprachen: Diese besitzen einen globalen Taktgeber. Zu jedem Takt werden Daten von Sensoren ausgelesen, Berechnungen ausgeführt oder Anweisungen an andere Systeme geschickt. Nun möchte man in so einem System vielleicht auch Berechnungen haben, die länger dauern als einen Takt, z.B. 10 Takte. Diese müssen mit anderen Berechnungen synchronisiert werden. Um zu überprüfen, dass alle Prozesse aufeinander abgestimmt sind (z.B. ein Prozess erwartet einen Input von einem anderem Prozess genau zu dem Takt wo der andere Prozess fertig ist), kann man abhängige Typen verwenden.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=3Ltgkjpme-Y">Freer Monads, More Extensible Effects</a> von Oleg Kiselyov (<a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Paper</a>)<br />
 Dieses Thema werden wir noch genauer im Curry Club besprechen. Der Vortrag baut auf den Ideen zur performanten Implementierung von freien Monaden des Papers <a href="http://okmij.org/ftp/Haskell/zseq.pdf">Reflection without remorse</a> von der letztjährigen ICFP (<a href="https://youtube.com/watch?v=_XoI65Rxmss">Video des Vortrags</a>) auf.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=bEJKKquyngk">Dependent Types and Effects in F*</a> von Nik Swamy und Catalin Hritcu<br />
 F* ist ein ML-Dialekt, welcher abhängige Typen, Refinement Types und ein Effektsystem kombiniert. Dank Einbinding eines SMT-Solvers können Beweise automatisiert werden. Falls der SMT-Solver scheitert, kann man per Hand einen Beweisterm angeben. Es kann ML-Code extrahiert werden. (Leider auch ein Beispiel dafür, warum man Text auf Folien auf keinen Fall grau machen sollte!)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=_1_3wi_sLKo">Meta Programming and Auto Tuning in the Search for High Performance GPU Code</a> von Michael Vollmer<br />
 Stellt eine DSL vor, mit der man performanten Code für die GPU schreiben kann, vor. Zur Performanceoptimierung des Codes wird eine automatisierte Suche verwendet. Der Programmierer kann die Suchparameter einstellen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=s0wkCKZU3WI">Injective Type Families for Haskell</a> von Jan Stolarek<br />
 Wenn man Haskell programmiert, ist man manchmal gezwungen, Phantom-Parameter einzuführen, deren einziger Zweck es ist, einen Typ eindeutig festzulegen. In vielen Fällen liegt das daran, dass Typfamilien nicht injektiv sind. Das bedeutet, dass wenn TF eine Typfamilie vom Kind * -&gt; * ist, man nicht vom Typ <code>TF a</code> auf den Typ <code>a</code> schließen kann. Deswegen kann man nicht einfach die Typsignatur <code>TF a -&gt; Int</code> verwenden, sondern muss noch einen Phantomtyp einführen: <code>phantom a -&gt; TF a -&gt; Int</code>. (Ich hab leider kein Beispiel aus dem echten Leben zur Hand.) Dieser Vortrag beschreibt, wie man in Zukunft bestimmte Typfamilien in GHC als injektiv kennzeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=UizO7fZSkPY">A Typechecker Plugin for Units of Measure</a> von Adam Gundry<br />
 Wie man ein GHC-Typsystem-Plugin schreibt, das Haskell beibringt, mit physikalischen Einheiten umzugehen. So etwas ist auch in <a href="http://www.idris-lang.org/">Idris</a> ohne weiteres möglich und darum gibt es eine <a href="https://github.com/timjb/quantities">Idris Bibliothek von Tim</a>, die genau das tut.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=vXRIXkbjLbU">Type Level Web APIs</a> von Andres Löh<br />
 Ein Vortrag über das Webframework <a href="https://hackage.haskell.org/package/servant">Servant</a>. In Servant schreibt man zunächst eine Art Sitemap der Webseite, in der Routen, Parameter und HTTP-Methoden und Rückgabewerte der Seite beschrieben sind. Diese Sitemap schreibt man in einer Art DSL auf Typebene. Man kann diese Sitemap dann für verschiedene Zwecke nutzen, zum Beispiel um die Seite auch tatsächlich zu implementieren (dabei muss man sich dann nicht um das Routing oder das Formatieren des Outputs kümmern), um Dokumentation zu erzeugen, um eine Client-Library in JavaScript zu generieren oder um Funktionen zu erhalten, mit denen sich die Webseite als Client ansprechen lässt. Ein interessanter Ansatz, den sich jeder mal anschauen sollte!</p></li>
</ul>
<p>Viel Spaß beim Ansehen!</p>
</article>
]]></description>
    <pubDate>Wed, 16 Sep 2015 00:00:00 UT</pubDate>
    <guid>http://curry-club-augsburg.de/posts/2015-09-16-hitliste-der-ICFP-talks.html</guid>
    <dc:creator>Curry Club Augsburg</dc:creator>
</item>

    </channel>
</rss>
