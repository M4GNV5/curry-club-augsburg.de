<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Hitliste der Talks von der ICFP :: Curry Club Augsburg</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="shortcut icon" href="../images/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />
    <link rel="stylesheet" href="https://api.tiles.mapbox.com/mapbox.js/v2.1.6/mapbox.css" />
  </head>
  <body>
    <div class="wrap">
      <div class="main">
        <header>
          <div id="logo">
            <a href="../">
              <img src="../images/logo-dunkler-hintergrund.svg" alt="Curry Club Augsburg" />
            </a>
          </div>
          <blockquote>
            <p>Das wird heiß</p>
            <footer>
              &mdash; <cite class="author">Makarius</cite>
            </footer>
          </blockquote>
          <div class="clear"></div>
        </header>

        <main id="content">
          <article>
  <header>
    <h1>Hitliste der Talks von der ICFP</h1>
    <div class="info">
      Gepostet am 16. September 2015
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> hat die offizielle Curry Club Empfehlungsliste für Talks von der diesjährigen <a href="http://www.icfpconference.org/">ICFP</a> erstellt. Wir wünschen angenehme Stunden der funktionalen Weiterbildung!</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=ga83zOo95bs">The State of GHC von SPJ</a> Ein Ausblick auf GHC 8.0. Pflichtvideo. (Achtung: Comic Sans in gelb auf blau.)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=ZEUTndOzrvw">The State of GHCJS von Luite Stegeman</a> Kurzzusammenfassung: GHCJS ist mit GHC 7.10.2 endlich einfach zu installieren. Es gibt eine neue Version der GHCJS-Standardbibliothek. Es steht einem Praxiseinsatz von GHCJS nichts mehr im Wege!</p></li>
<li><p><a href="https://www.youtube.com/watch?v=hI0ajVy2xEk">Practical Probabilistic Programming with Monads von Adam Scibior</a> Eine DSL, mit der man bayesische Inferenz betreiben kann. (sehr interessant)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=AFSLMTgoClI">GADTs Meet Their Match von George Karachalias</a> Wenn man in Haskell eine Funktion “a -&gt; b” definiert, dann überprüft GHC, ob man mit der Definition jeden mögliche Eingabe abgedeckt hat. Das funktioniert aber noch nicht so gut, wenn a ein GADT ist. Der Vortrag beschreibt einen Algorithmus, der dieses Problem löst.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=PrDSxnO29d0">Look Ma, No Signatures! von Edward Z. Yang</a> Wie bringt man GHC bei, rekursiv voneinander abhängige Module zu kompilieren? (sehr unterhaltsam)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=T88TDS7L5DY">The Unreasonable Effectiveness of Lenses for Business Applications von Edward Kmett</a> Ein Lens-Vortrag vom geliebten Propheten höchstpersönlich. Außerdem: Sonderpreis für den besten Vortragstitel</p></li>
<li><p><a href="https://www.youtube.com/watch?v=WajfYdqCeAM">Practical Principled FRP von Atze van der Ploeg</a> Untertitel: Forget the past, change the future! FRPNow! Ein neuer Ansatz für Functional Reactive Programming.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NVEgyJCTee4">The History of Standard ML: Ideas, Principles, Culture</a> Von Makarius empfohlen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=RRmb2RtU0hU">Stack</a> Über die neue “cabal”-Alternative. Ich habe sehr gute Erfahrungen mit Stack gemacht. Das Tool tut einfach zuverlässig das, was es soll, ohne große Dependency-Schwierigkeiten, wobei es aber auf ältere Pakete setzt, also auf Hackage verfügbar.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=lNSfVpKEnnI">Which simple Types have a unique Inhabitant? von Gabriel Scherer</a> Es wird ein Algorithmus skizziert, der diese Frage wird im Setting des einfach typisierten Lambda-Kalküls beantwortet. In komplexeren Typsystemen ist diese Frage unentscheidbar. Ein Algorithmus, der diese Frage in vielen Fällen beantwortet kann aber trotzdem hilfreich für Programmierer sein.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=W6a36RoFeNw">Future of Haskell: Dependent types von Richard Eisenberg</a> Es gibt den Plan, GHC abhängige Typen beizubringen. Dieser Vortrag stellt kurz (in ca 5min) vor, was damit möglich sein wird. Danach gibt es eine lange Diskussion.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=guMLPr6eBLo">The Remote Monad Design Pattern</a> Wie man durch Bündeln von Kommandos mit möglichst wenigen Netzwerkzugriffen andere Geräte, wie z.B. Toaster steuert.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=oAz8AEf7WDA">Diagrams: a Functional EDSL for Vector Graphics</a> Über die supercoole Bibliothek diagrams, mit der man Vektorgraphiken mit Haskell zeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=D1rm5SnvmKE">Guilt Free Ivory</a> Design einer Haskell-DSL, die sicheren C-Code für eingebettete Systeme erzeugt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NBBQoX1EWCY">Monadic Effects</a> Beschreibt die Sprache Koka, die nach JavaScript kompiliert und ein Effektsystem besitzt. Es ist dabei möglich, eigene Effekte zu implementieren, indem man einfach eine Monadeninstanz schreibt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=nBaRKI5q-DI">Dependent Types for Real time Constraints</a> Für Real-Time-Systeme (z.B. der Flugkontrolle in einem Flugzeug) gibt es synchrone Programmiersprachen: Diese besitzen einen globalen Taktgeber. Zu jedem Takt werden Daten von Sensoren ausgelesen, Berechnungen ausgeführt oder Anweisungen an andere Systeme geschickt. Nun möchte man in so einem System vielleicht auch Berechnungen haben, die länger dauern als einen Takt, z.B. 10 Takte. Diese müssen mit anderen Berechnungen synchronisiert werden. Um zu überprüfen, dass alle Prozesse aufeinander abgestimmt sind (z.B. ein Prozess erwartet einen Input von einem anderem Prozess genau zu dem Takt wo der andere Prozess fertig ist), kann man abhängige Typen verwenden.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=3Ltgkjpme-Y">Freer Monads, More Extensible Effects von Oleg Kiselyov</a> Das <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">zugehörige Paper findet man auch hier</a>. Und <a href="http://okmij.org/ftp/Haskell/zseq.pdf">so implementiert man performante freie Monaden</a>. Dieses Thema werden wir noch genauer im Curry Club besprechen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=bEJKKquyngk">Dependent Types and Effects in F*</a> F* ist ein ML-Dialekt, welcher abhängige Typen, Refinement Types und ein Effektsystem kombiniert. Dank Einbinding eines SMT-Solvers können Beweise automatisiert werden. Falls der SMT-Solver scheitert, kann man per Hand einen Beweisterm angeben. Es kann ML-Code extrahiert werden. (Leider auch ein Beispiel dafür, warum man Text auf Folien auf keinen Fall grau machen sollte!)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=_1_3wi_sLKo">Meta Programming and Auto Tuning in the Search for High Performance GPU Code</a> Stellt eine DSL vor, mit der man performanten Code für die GPU vor. Es stellt sich heraus, dass man dafür dem Programmierer etwas Kontrolle über die Wahl des Optimierungsalgorithmus geben muss.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=s0wkCKZU3WI">Injective Type Families for Haskell</a> Wenn man Haskell programmiert, ist man manchmal gezwungen, Phantom-Parameter einzuführen, deren einziger Zweck es ist, einen Typ eindeutig festzulegen. In vielen Fällen liegt das daran, dass Typfamilien nicht injektiv sind. Das bedeutet, dass wenn TF eine Typfamilie vom Kind * -&gt; * ist, man nicht vom Typ <code>TF a</code> auf den Typ <code>a</code> schließen kann. Deswegen kann man nicht einfach die Typsignatur <code>TF a -&gt; Int</code> verwenden, sondern muss noch einen Phantomtyp einführen: <code>phantom a -&gt; TF a -&gt; Int</code>. (Ich hab leider kein Beispiel aus dem echten Leben zur Hand.) Dieser Vortrag beschreibt, wie man in Zukunft bestimmte Typfamilien in GHC als injektiv kennzeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=UizO7fZSkPY">A Typechecker Plugin for Units of Measure von Adam Gundry</a> Wie man ein GHC-Typsystem-Plugin schreibt, das Haskell beibringt, mit physikalischen Einheiten umzugehen. So etwas ist auch in <a href="http://www.idris-lang.org/">Idris</a> ohne weiteres möglich und darum gibt es eine <a href="https://github.com/timjb/quantities">Idris Bibliothek von Tim</a>, die genau das tut.</p></li>
</ul>
<p>Viel Spaß beim Ansehen!</p>
</article>

        </main>
      </div>
    </div>

    <footer class="footer">
      Mit viel <b>&lambda;</b> und mit Hilfe von <a href="http://jaspervdj.be/hakyll">Hakyll</a> erstellt.
      Schau dir den <a href="https://github.com/curry-club-aux/curry-club-augsburg.de">Quellcode</a> an und verbessere ihn!
    </footer>
  </body>
</html>
