<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Curry Club Augsburg</title>
    <link href="http://curry-club-augsburg.de/atom.xml" rel="self" />
    <link href="http://curry-club-augsburg.de" />
    <id>http://curry-club-augsburg.de/atom.xml</id>
    <author>
        <name>Curry Club Augsburg</name>
        <email>post@curry-club-augsburg.de</email>
    </author>
    <updated>2015-10-14T00:00:00Z</updated>
    <entry>
    <title>Einladung zum großen Haskell-Workshop des Curry Clubs Augsburg am 25. Oktober 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-10-14-einladung-haskell-workshop.html" />
    <id>http://curry-club-augsburg.de/posts/2015-10-14-einladung-haskell-workshop.html</id>
    <published>2015-10-14T00:00:00Z</published>
    <updated>2015-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Einladung zum großen Haskell-Workshop des Curry Clubs Augsburg am 25. Oktober 2015</h1>
    <div class="info">
      Gepostet am 14. Oktober 2015
      
          von Ingo Blechschmidt
      
    </div>
    
    <img src="/images/learn-you-a-haskell-for-great-good.png" alt="Learn you a Haskell for great good" />
    
    
    <div class="attribution"><p><a href="http://learnyouahaskell.com/">LearnYouAHaskell</a> (CC BY-NC-SA)</p></div>
    
  </header>

  <p>Liebe Freundinnen und Freunde von verallgemeinertem abstrakten Nonsens!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu einem <strong>Haskell-Workshop für Neulinge</strong> ein. Dieser findet am <strong>25. Oktober 2015</strong>, einem Sonntag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Die Teilnahme ist kostenlos.</p>
<p>Haskell ist eine wunderschöne Sprache, in der man nicht das “wie” spezifiziert, sondern das “was”. Ein Haskell-Programm besteht – anders als bei allen gewöhnlichen Programmiersprachen – nicht aus einer Folge von Anweisungen, welche von oben nach unten ausgeführt (und nur durch Kontrollstrukturen oder Subroutinen aufgelockert) werden. Haskell-Code kann man fast beliebig in seiner Reihenfolge permutieren, ohne die Bedeutung zu verändern. Ein ausführlicher Werbetext steht unten.</p>
<p>Zielgruppe des Workshops sind in erster Linie völlige Haskell-Neulinge. Teilnahmevoraussetzung ist entweder Erfahrung mit einer beliebigen anderen Programmiersprache oder Vertrautheit mit mathematisch/abstraktem Denken. Wer Haskell schon etwas besser kennt, wird auch auf seine Kosten kommen: Dann gibt es parallel zum Hauptprogramm eine Einführung und Übungsaufgaben zur Standardbibliothek. Haskell-Profis sollten keinesfalls als Teilnehmende mitmachen, sondern lieber das Betreuendenteam verstärken.</p>
<p>Wer vorhat, am Workshop teilzunehmen, kann sich in ein <a href="https://ola.pads.ccc.de/haskell-workshop-2015">Organisationspad</a> eintragen und dann am 25. Oktober mit dem eigenen Laptop ins OpenLab kommen. Bitte vorab die <a href="https://www.haskell.org/platform/">Haskell Platform</a> installieren, um auf dem Workshop Zeit zu sparen.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<p><strong>Update:</strong> <a href="https://github.com/curry-club-aux/haskell-workshop/raw/gh-pages/uebung.pdf">Die Übungsaufgaben vom Workshop sind online.</a></p>
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das achte Treffen am 5. November 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-09-19-ankuendigung-achtes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-09-19-ankuendigung-achtes-treffen.html</id>
    <published>2015-09-19T00:00:00Z</published>
    <updated>2015-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das achte Treffen am 5. November 2015</h1>
    <div class="info">
      Gepostet am 19. September 2015
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/larsrh">Lars</a> wird eine kurze Einführung in Scala geben und die Sprache mit Haskell und ML vergleichen. Der Vortrag ist angelehnt an “What Haskell can learn from Scala” vom <a href="https://skillsmatter.com/conferences/7069-haskell-exchange-2015#program">diesjährigen Haskell eXchange</a>.</p>
<p>Ziemlich sicher wird <a href="https://github.com/iblech">Ingo</a> einen Vortrag über Effektsysteme und den neuesten <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Aufsatz von Oleg</a> halten.</p>
<p>Vielleicht gibt es auch einen Vortrag zu Functional Reactive Programming.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Hitliste der Talks von der ICFP</title>
    <link href="http://curry-club-augsburg.de/posts/2015-09-16-hitliste-der-ICFP-talks.html" />
    <id>http://curry-club-augsburg.de/posts/2015-09-16-hitliste-der-ICFP-talks.html</id>
    <published>2015-09-16T00:00:00Z</published>
    <updated>2015-09-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Hitliste der Talks von der ICFP</h1>
    <div class="info">
      Gepostet am 16. September 2015
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> hat die offizielle Empfehlungsliste des Curry Clubs für Talks von der diesjährigen <a href="http://www.icfpconference.org/">ICFP</a> erstellt. Wir wünschen angenehme Stunden der funktionalen Weiterbildung!</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=ga83zOo95bs">The State of GHC</a> von Simon Peyton Jones<br />
 Ein Ausblick auf GHC 8.0. Pflichtvideo. (Achtung: Comic Sans in gelb auf blau.)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=ZEUTndOzrvw">The State of GHCJS</a> von Luite Stegeman<br />
 Kurzzusammenfassung: GHCJS ist mit GHC 7.10.2 endlich einfach zu installieren. Es gibt eine neue Version der GHCJS-Standardbibliothek. Es steht einem Praxiseinsatz von GHCJS nichts mehr im Wege!</p></li>
<li><p><a href="https://www.youtube.com/watch?v=hI0ajVy2xEk">Practical Probabilistic Programming with Monads</a> von Adam Scibior<br />
 Eine DSL, mit der man bayesische Inferenz betreiben kann. (sehr interessant)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=AFSLMTgoClI">GADTs Meet Their Match</a> von George Karachalias<br />
 Wenn man in Haskell eine Funktion “a -&gt; b” definiert, dann überprüft GHC, ob man mit der Definition jede mögliche Eingabe abgedeckt hat. Das funktioniert aber noch nicht so gut, wenn a ein GADT ist. Der Vortrag beschreibt einen Algorithmus, der dieses Problem löst.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=PrDSxnO29d0">Look Ma, No Signatures!</a> von Edward Z. Yang<br />
 Wie bringt man GHC bei, rekursiv voneinander abhängige Module zu kompilieren? (sehr unterhaltsam)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=T88TDS7L5DY">The Unreasonable Effectiveness of Lenses for Business Applications</a> von Edward Kmett<br />
 Ein Lens-Vortrag vom geliebten Propheten höchstpersönlich. Außerdem: Sonderpreis für den besten Vortragstitel</p></li>
<li><p><a href="https://www.youtube.com/watch?v=WajfYdqCeAM">Practical Principled FRP</a> von Atze van der Ploeg<br />
 Untertitel: Forget the past, change the future! FRPNow! Ein neuer Ansatz für Functional Reactive Programming.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NVEgyJCTee4">The History of Standard ML: Ideas, Principles, Culture</a> von David MacQueen<br />
 Von Makarius empfohlen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=RRmb2RtU0hU">Stack</a> von Emanual Borsboom<br />
 Über die neue <code>cabal</code>-Alternative. Ich habe sehr gute Erfahrungen mit Stack gemacht. Im Gegensatz zu Cabal hatte ich mit Stack noch nie Probleme damit, dass verschiedene Pakete unterschiedliche Versionen von Dependencies vorausgesetzt haben. Es verwendet dazu eine kuratierte Datenbank von Paketen und Schnappschüssen von miteinander verträglichen Versionen von diesen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=lNSfVpKEnnI">Which simple Types have a unique Inhabitant?</a> von Gabriel Scherer<br />
 Es wird ein Algorithmus skizziert, der diese Frage wird im Setting des einfach typisierten Lambda-Kalküls beantwortet. In komplexeren Typsystemen ist diese Frage unentscheidbar. Ein Algorithmus, der diese Frage in vielen Fällen beantwortet kann aber trotzdem hilfreich für Programmierer sein.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=W6a36RoFeNw">Future of Haskell: Dependent types</a> von Richard Eisenberg<br />
 Es gibt den Plan, GHC abhängige Typen beizubringen. Dieser Vortrag stellt kurz (in ca 5min) vor, was damit möglich sein wird. Danach gibt es eine lange Diskussion.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=guMLPr6eBLo">The Remote Monad Design Pattern</a> von Andy Gill<br />
 Wie man durch Bündeln von Kommandos mit möglichst wenigen Netzwerkzugriffen andere Geräte, wie z.B. Toaster steuert.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=oAz8AEf7WDA">Diagrams: A Functional EDSL for Vector Graphics</a> von Ryan Yates und Brent Yorgey<br />
 Über die supercoole Bibliothek <a href="http://projects.haskell.org/diagrams/"><code>diagrams</code></a>, mit der man Vektorgraphiken mit Haskell zeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=D1rm5SnvmKE">Guilt Free Ivory</a> von Galois<br />
 Design einer Haskell-DSL, die sicheren C-Code für eingebettete Systeme erzeugt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=NBBQoX1EWCY">Monadic Effects</a> von Niki Vazou und Daan Leijen<br />
 Beschreibt die Sprache Koka, die nach JavaScript kompiliert und ein Effektsystem besitzt. Es ist dabei möglich, eigene Effekte zu implementieren, indem man einfach eine Monadeninstanz schreibt.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=nBaRKI5q-DI">Dependent Types for Real time Constraints</a> von William Blair<br />
 Für Real-Time-Systeme (z.B. der Flugkontrolle in einem Flugzeug) gibt es synchrone Programmiersprachen: Diese besitzen einen globalen Taktgeber. Zu jedem Takt werden Daten von Sensoren ausgelesen, Berechnungen ausgeführt oder Anweisungen an andere Systeme geschickt. Nun möchte man in so einem System vielleicht auch Berechnungen haben, die länger dauern als einen Takt, z.B. 10 Takte. Diese müssen mit anderen Berechnungen synchronisiert werden. Um zu überprüfen, dass alle Prozesse aufeinander abgestimmt sind (z.B. ein Prozess erwartet einen Input von einem anderem Prozess genau zu dem Takt wo der andere Prozess fertig ist), kann man abhängige Typen verwenden.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=3Ltgkjpme-Y">Freer Monads, More Extensible Effects</a> von Oleg Kiselyov (<a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Paper</a>)<br />
 Dieses Thema werden wir noch genauer im Curry Club besprechen. Der Vortrag baut auf den Ideen zur performanten Implementierung von freien Monaden des Papers <a href="http://okmij.org/ftp/Haskell/zseq.pdf">Reflection without remorse</a> von der letztjährigen ICFP (<a href="https://youtube.com/watch?v=_XoI65Rxmss">Video des Vortrags</a>) auf.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=bEJKKquyngk">Dependent Types and Effects in F*</a> von Nik Swamy und Catalin Hritcu<br />
 F* ist ein ML-Dialekt, welcher abhängige Typen, Refinement Types und ein Effektsystem kombiniert. Dank Einbinding eines SMT-Solvers können Beweise automatisiert werden. Falls der SMT-Solver scheitert, kann man per Hand einen Beweisterm angeben. Es kann ML-Code extrahiert werden. (Leider auch ein Beispiel dafür, warum man Text auf Folien auf keinen Fall grau machen sollte!)</p></li>
<li><p><a href="https://www.youtube.com/watch?v=_1_3wi_sLKo">Meta Programming and Auto Tuning in the Search for High Performance GPU Code</a> von Michael Vollmer<br />
 Stellt eine DSL vor, mit der man performanten Code für die GPU schreiben kann, vor. Zur Performanceoptimierung des Codes wird eine automatisierte Suche verwendet. Der Programmierer kann die Suchparameter einstellen.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=s0wkCKZU3WI">Injective Type Families for Haskell</a> von Jan Stolarek<br />
 Wenn man Haskell programmiert, ist man manchmal gezwungen, Phantom-Parameter einzuführen, deren einziger Zweck es ist, einen Typ eindeutig festzulegen. In vielen Fällen liegt das daran, dass Typfamilien nicht injektiv sind. Das bedeutet, dass wenn TF eine Typfamilie vom Kind * -&gt; * ist, man nicht vom Typ <code>TF a</code> auf den Typ <code>a</code> schließen kann. Deswegen kann man nicht einfach die Typsignatur <code>TF a -&gt; Int</code> verwenden, sondern muss noch einen Phantomtyp einführen: <code>phantom a -&gt; TF a -&gt; Int</code>. (Ich hab leider kein Beispiel aus dem echten Leben zur Hand.) Dieser Vortrag beschreibt, wie man in Zukunft bestimmte Typfamilien in GHC als injektiv kennzeichnen kann.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=UizO7fZSkPY">A Typechecker Plugin for Units of Measure</a> von Adam Gundry<br />
 Wie man ein GHC-Typsystem-Plugin schreibt, das Haskell beibringt, mit physikalischen Einheiten umzugehen. So etwas ist auch in <a href="http://www.idris-lang.org/">Idris</a> ohne weiteres möglich und darum gibt es eine <a href="https://github.com/timjb/quantities">Idris Bibliothek von Tim</a>, die genau das tut.</p></li>
<li><p><a href="https://www.youtube.com/watch?v=vXRIXkbjLbU">Type Level Web APIs</a> von Andres Löh<br />
 Ein Vortrag über das Webframework <a href="https://hackage.haskell.org/package/servant">Servant</a>. In Servant schreibt man zunächst eine Art Sitemap der Webseite, in der Routen, Parameter und HTTP-Methoden und Rückgabewerte der Seite beschrieben sind. Diese Sitemap schreibt man in einer Art DSL auf Typebene. Man kann diese Sitemap dann für verschiedene Zwecke nutzen, zum Beispiel um die Seite auch tatsächlich zu implementieren (dabei muss man sich dann nicht um das Routing oder das Formatieren des Outputs kümmern), um Dokumentation zu erzeugen, um eine Client-Library in JavaScript zu generieren oder um Funktionen zu erhalten, mit denen sich die Webseite als Client ansprechen lässt. Ein interessanter Ansatz, den sich jeder mal anschauen sollte!</p></li>
</ul>
<p>Viel Spaß beim Ansehen!</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das siebte Treffen am 8. Oktober 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-08-14-ankuendigung-siebtes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-08-14-ankuendigung-siebtes-treffen.html</id>
    <published>2015-08-14T00:00:00Z</published>
    <updated>2015-08-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das siebte Treffen am 8. Oktober 2015</h1>
    <div class="info">
      Gepostet am 14. August 2015
      
          von Tim Baumann
      
    </div>
    
    <img src="/images/hacker-barbie.png" alt="Hacker Barbie" />
    
    
    <div class="attribution"><p>Nach der Schule trifft Barbie Paul und Peter in der Bibliothek. "Funktionale Programmierung ist fantastisch!", freut sich Barbie. "Ich weiß nicht", sagt Paul, "was zum Teufel ist eine Monade noch mal?". "Eine Monade ist einfach ein Monoid in einer Kategorie von Endofunktoren – wo liegt das Problem?", antwortet Barbie.</p></div>
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> wird seinen Dreiteiler über Lens abschließen. Die Vortragsfolien gibt es <a href="/files/lens.pdf">hier</a> und die Codebeispiele <a href="https://github.com/timjb/presentations/tree/gh-pages/lens">auf Github</a>. Das letzte Mal sind wir bis zu Folie 91 gekommen.</p>
<script async class="speakerdeck-embed" data-id="4e2df73019d74b28beec25cb2b08e348" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><a href="https://github.com/iblech">Ingo</a> wird seinen Vortrag über <a href="/files/freie-monaden.pdf">Monoide, freie Monoide und Monaden als Monoide</a> abschließen. <a href="/files/freie-monaden.pdf">Folien</a>, <a href="https://github.com/iblech/vortrag-haskell/blob/master/freie-monaden.txt">Transcript</a>, <a href="https://github.com/iblech/vortrag-haskell/blob/master/freie-monaden.hs">Code</a>.</p>
<p>Vielleicht wird es außerdem Vorträge über Effektsysteme, den neuesten <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Aufsatz von Oleg</a> und Functional Reactive Programming geben.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das sechste Treffen am 10. September 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-07-25-ankuendigung-sechstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-07-25-ankuendigung-sechstes-treffen.html</id>
    <published>2015-07-25T00:00:00Z</published>
    <updated>2015-07-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das sechste Treffen am 10. September 2015</h1>
    <div class="info">
      Gepostet am 25. Juli 2015
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/timjb">Tim</a> wird seinen Vortrag über Lens vom letzten Mal fortsetzen. Die Vortragsfolien gibt es <a href="/files/lens.pdf">hier</a> und die Codebeispiele <a href="https://github.com/timjb/presentations/tree/gh-pages/lens">auf Github</a>.</p>
<script async class="speakerdeck-embed" data-id="4e2df73019d74b28beec25cb2b08e348" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><a href="https://github.com/iblech">Ingo</a> lädt zum großen monadischen Abend ein und wird daher über <a href="/files/freie-monaden.pdf">Monoide, freie Monoide und Monaden als Monoide</a> berichten. Ziel wird sein, das schöne Motto <em>Monaden sind nichts anderes als Monoide in einer Kategorie von Endofunktoren</em> zu verstehen. Wenn noch Zeit ist, werden wir auch auf freie Monaden eingehen. Dies ist der zweite Vortrag in der Reihe <em>What the Kmett is a monad?</em>. Beim nächsten Treffen dann wird es einen darauf aufbauenden Vortrag über Effektsysteme und den neuesten <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Aufsatz von Oleg</a> geben.</p>
<p><a href="http://sketis.net/">Makarius</a> führt die Reihe <em>SML ist die beste unbekannte Programmiersprache der Welt</em> durch eine Kurzpräsentation des source-level Debuggers in der Prover-IDE fort.</p>
<p>Als dreiminütigen Lückenfüller gibt es eine Erklärung, welchen einfachen Zaubertrick man mit Münzen und dem Haskell-Programm <code>length . group</code> vorführen kann.</p>
<p><em>Um den Abend gemütlich ausklingen zu lassen, wird es selbstgekochtes Curry geben.</em> Wer eine Portion haben möchte, schickt an <code>tim@timbaumann.info</code> eine Mail mit Betreff <code>(+1)</code> (oder einem semantisch identischen Haskell-Programm).</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Drittes Treffen des Curry Clubs</title>
    <link href="http://curry-club-augsburg.de/posts/2015-07-02-drittes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-07-02-drittes-treffen.html</id>
    <published>2015-07-02T00:00:00Z</published>
    <updated>2015-07-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Drittes Treffen des Curry Clubs</h1>
    <div class="info">
      Gepostet am  2. Juli 2015
      
          von Profpatsch
      
    </div>
    
    <img src="/images/curry-club-03.jpg" alt="Bild vom Treffen" />
    
    
    <div class="attribution"><p>CC BY-NC-ND 4.0</p></div>
    
  </header>

  <h1 id="über-scala-logik-kategorien-und-yolomorphismen">Über Scala, Logik, Kategorien und Yolomorphismen</h1>
<p>Das dritte Treffen war wieder ein sehr lehrreicher Abend gespickt mit funktionalem Witz und vielen Einblicken in tolle Themen.</p>
<h2 id="leon">Leon</h2>
<p>Mit <a href="http://leon.epfl.ch/">Leon</a> wurde uns ein System vorgestellt, dass den Scala-Compiler um einige interessante Möglichkeiten erweitert; So kann man direkt Pre- und Postconditions einfügen, die dann vom Compiler mittels eines automatischen Theorembeweisers überprüft werden. Am Ende zeigte er uns dann noch, dass man sogar den Code generieren lassen kann.</p>
<h2 id="prolog">Prolog</h2>
<p>Eine Einführung in <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> anhand eines praktischen Beispiels brachte uns die Vorteile und Grenzen der Sprache nahe. Das Resümee war dann, dass man Prolog sehr gut als domainspezifische Sprache über das C-Interface einbinden kann, aber es nicht als Allzweckprogrammiersprache („general Purpose“) verwenden will.</p>
<p>Weite Zustimmung fand die Alternative, das Logikproblem (soweit möglich) in aussagenlogische Ausdrücke zu transformieren und dann in einen <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT">SAT-Solver</a> zu stecken. Diese sind mittlerweile sehr schnell geworden.</p>
<h2 id="kategorientheorie">Kategorientheorie</h2>
<p>Am Ende ging es dann nochmal in die Mathematik und Ingo gab uns eine Einführung in die Kategorientheorie. Der Vortrag war sehr gut nachvollziehbar, was unter anderem auch an den <a href="/files/was-sollen-kategorien.pdf">Folien</a> lag. Aber um es wirklich nachvollziehen zu können, muss man natürlich das Treffen besuchen. :)</p>
<p>Nächstes Mal gibt es die Fortsetzung.</p>
<h2 id="zusammenfassung">Zusammenfassung</h2>
<p>Alles in allem war es ein sehr gelungener Abend und auch die Gespräche im <a href="http://www.sangam-augsburg.de/">Sangam</a> hinterher sehr erhellend. Zum Beispiel haben wir gelernt, dass man nicht-totale Funktionen wie <code>head</code>, <code>tail</code> und <code>(!!)</code> <em>Yolomorphismen</em> nennen sollte. Zu den Yolomorphismen sollte man auch <code>unsafePerformIO :: IO a -&gt; a</code>, sowie die Mutter aller Yolomorphismen, die Funktion <code>unsafeCoerce :: a -&gt; b</code>, zählen.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das fünfte Treffen am 13. August 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-05-28-ankuendigung-fuenftes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-05-28-ankuendigung-fuenftes-treffen.html</id>
    <published>2015-05-28T00:00:00Z</published>
    <updated>2015-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das fünfte Treffen am 13. August 2015</h1>
    <div class="info">
      Gepostet am 28. Mai 2015
      
          von Tim Baumann
      
    </div>
    
    <img src="/images/diagrams-rubiks-cube.svg" alt="Mit Haskell erstellte Skizzen des Zauberwürfels" />
    
    
    <div class="attribution"><p><a href="http://github.com/timjb/diagrams-rubiks-cube.com/">Tim Baumann</a> (MIT)</p></div>
    
  </header>

  <p><a href="https://github.com/mgudemann">Matthias</a> stellt Mercury vor.</p>
<p><a href="https://github.com/timjb">Tim</a> stellt Lenses vor, anschaulich erklärt mit seinem <a href="https://github.com/timjb/diagrams-rubiks-cube">Haskell-Paket für Zauberwürfel-Diagramme</a>. Die Vortragsfolien gibt es <a href="/files/lens.pdf">hier</a> und die Codebeispiele <a href="https://github.com/timjb/presentations/tree/gh-pages/lens">auf Github</a>.</p>
<script async class="speakerdeck-embed" data-id="4e2df73019d74b28beec25cb2b08e348" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p>Schließlich gibt es auch noch einen Kurzvortrag von <a href="https://github.com/maximilianhuber">Maximilian</a>: Wie kann man in Haskell ansprechende Textmodus-Oberflächen zaubern?</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das vierte Treffen am 16. Juli 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-05-27-ankuendigung-viertes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-05-27-ankuendigung-viertes-treffen.html</id>
    <published>2015-05-27T00:00:00Z</published>
    <updated>2015-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das vierte Treffen am 16. Juli 2015</h1>
    <div class="info">
      Gepostet am 27. Mai 2015
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p><a href="https://github.com/iblech">Ingo</a> setzt die <a href="/posts/2015-05-26-ankuendigung-drittes-treffen.html">Einführung in Kategorientheorie</a> fort.</p>
<p><a href="http://sketis.net/">Makarius</a> spielt mit ein paar Variationen von Currying in Isabelle: Das schließt sich im weitesten Sinne auch an die Kategorientheorie an, das heißt man geht mit Pfeilen, Produkten, Koprodukten etc. formal und spielerisch um.</p>
<h2 id="weitere-tops">Weitere TOPs:</h2>
<ul>
<li>Prozess für Themenfindung überlegen</li>
<li>Über Projekte &amp; alles andere ratschen (in Gruppen?)</li>
</ul>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das dritte Treffen am 18. Juni 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-05-26-ankuendigung-drittes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-05-26-ankuendigung-drittes-treffen.html</id>
    <published>2015-05-26T00:00:00Z</published>
    <updated>2015-05-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das dritte Treffen am 18. Juni 2015</h1>
    <div class="info">
      Gepostet am 26. Mai 2015
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p><a href="https://larsrh.github.io/">Lars</a> stellt <a href="https://github.com/epfl-lara/leon">Leon</a> vor, ein Tool zur Programmverifikation und -synthese speziell für Scala. „Leon ist interessant, weil es interaktiv ist, d.h. es gibt schnell Feedback, und man braucht nicht viel über Logik zu wissen.“</p>
<p><a href="http://github.com/iblech/">Ingo</a> macht eine Einführung in die Kategorientheorie:</p>
<div class="abstract">
<p>Die Sprache der Kategorien hat sich in mehreren Teilgebieten der Mathematik, Informatik und Physik als Lingua franca etabliert. Sowohl von Fans als auch von Spöttern wird Kategorientheorie als “verallgemeinerter abstrakter Nonsens” tituliert; kategorielle Konzepte und konkrete Ausprägungen allgemeiner kategorieller Beobachtungen finden sich überall.</p>
<p>Für (nicht nur) funktionale Programmierung hilft Kategorientheorie um wiederkehrende Muster zu erkennen und auszunutzen, um elegante Theorien von Datentypen zu entwickeln und um die Semantik von Sprachen zu beschreiben. Außerdem benötigt man Kategorientheorie natürlich um Edward Kmetts Arbeiten zu Kan-Erweiterungen und anderen kategoriellen Konzepten in Haskell zu würdigen; aufgrund einer wunderbaren Fügung sind seine Pakete Abhängigkeiten von so profanen Dingen wie Web-Frameworks.</p>
<p>Der Vortrag wird in die erste Stufe von Kategorientheorie einführen: Kategorien, universelle Eigenschaften und Dualität. Wenn die Stimmung gut ist, sprechen wir auch noch über Funktoren. Bei diesem ersten Vortrag werden wir aber – wenn nicht explizit anders gewünscht – nicht über natürliche Transformation oder weiterführende Konzepte wie Limiten, Kolimiten, adjungierte Funktoren, Kan-Erweiterungen oder das Yoneda-Lemma sprechen.</p>
</div>
<p class="materials">
[<a href="http://pizzaseminar.speicherleck.de/was-sollen-kategorien/was-sollen-kategorien-curry-club.pdf">Vortragsfolien</a>]
</p>
<p><a href="http://weltraumpflege.org/">Richard</a> hält einen Vortrag über Logikprogrammierung im Allgemeinen und insbesondere die Umsetzung dieses Konzeptes in der Programmiersprache Prolog. Dabei werden folgende Fragen beantwortet: Was ist Logikprogrammierung überhaupt und warum will man das machen? Kann man damit auch seriöse Anwendungsentwicklung betreiben?</p>
<p>Es gibt den Plan, danach im <a href="http://www.sangam-augsburg.de/">Sangam</a> gemeinsam Essen zu gehen.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das zweite Treffen am 21. Mai 2015</title>
    <link href="http://curry-club-augsburg.de/posts/2015-05-15-ankuendigung-zweites-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2015-05-15-ankuendigung-zweites-treffen.html</id>
    <published>2015-05-15T00:00:00Z</published>
    <updated>2015-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das zweite Treffen am 21. Mai 2015</h1>
    <div class="info">
      Gepostet am 15. Mai 2015
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Tim wird seinen <a href="/posts/2015-04-28-erstes-treffen.html">Vortrag vom ersten Treffen über typsicheres Routing in Haskell</a> durch Programmierung auf Typ-Ebene fortsetzen.</p>
<p>Profpatsch stellt die Technik hinter unserer Webseite vor.</p>
<p>Lars hält einen Vortrag zu monadischer Ein-/Ausgabe. Damit beginnen wir die Serie <em>What the Kmett is a monad?</em>.</p>
<p>Makarius gibt uns eine kurze Einführung in Isabelle (mit einigen Anklängen an den Zusammenhang von funktionaler Programmierung und Logik, z.B. mit einem formalen Beweis der Aussage im Logo des Curry Club).</p>
</article>
]]></summary>
</entry>

</feed>
