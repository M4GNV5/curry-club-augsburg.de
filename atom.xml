<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Curry Club Augsburg</title>
    <link href="http://curry-club-augsburg.de/atom.xml" rel="self" />
    <link href="http://curry-club-augsburg.de" />
    <id>http://curry-club-augsburg.de/atom.xml</id>
    <author>
        <name>Curry Club Augsburg</name>
        <email>post@curry-club-augsburg.de</email>
    </author>
    <updated>2017-01-03T00:00:00Z</updated>
    <entry>
    <title>Vierter großer Haskell-Workshop des Curry Clubs Augsburg am 21. Januar 2017</title>
    <link href="http://curry-club-augsburg.de/posts/2017-01-03-vierter-workshop.html" />
    <id>http://curry-club-augsburg.de/posts/2017-01-03-vierter-workshop.html</id>
    <published>2017-01-03T00:00:00Z</published>
    <updated>2017-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Vierter großer Haskell-Workshop des Curry Clubs Augsburg am 21. Januar 2017</h1>
    <div class="info">
      Gepostet am  3. Jan 17
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <div class="right">
<p><a href="/files/haskellworkshop-plakat3.pdf"> <img width="300" src="/files/haskellworkshop-plakat3.png" /> </a></p>
</div>
<p>Liebe Freundinnen der Sonne!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu der Fortsetzung unseres <strong>Haskell-Workshops</strong> ein. Diese findet am <strong>21. Januar 2017</strong>, einem Samstag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Wie bei den vorherigen Malen ist die Teilnahme kostenlos.</p>
<p>Zielgruppe des Workshops sind alle Teilnehmerinnen der ersten drei Workshops. Etwas genauer: Man sollte in der Lage sein, ein Haskell-Programm zu schreiben, dass die Anzahl Blätter eines binären Baums zählt. Diese Aufgabe darf ruhig ein wenig dauern! Der Workshop richtet sich an alle, die keine Neulinge mehr sind; Expertin muss man aber noch lange nicht sein. Ganz besonders möchten wir die Teilnehmenden des dritten Workshops vom 17. Dezember 2016 ermuntern, an diesem Folgeworkshop teilzunehmen.</p>
<p>Wichtigster Programmpunkt beim Folgeworkshop sind Monaden (griechisch für “putzige flauschige Dinge”). Damit könnt ihr Ein- und Ausgabe betreiben, den Programmfluss pervers verbiegen, veränderliche Variablen bedienen (wenn es unbedingt sein muss), Dateiformate parsen, Logikrätsel lösen und Spiele programmieren. Außerdem werden wir über QuickCheck sprechen, einer sehr beliebten Möglichkeit, um die paar Programmierfehler, die das Typsystem nicht findet, zu fangen.</p>
<p>Damit wir unsere Kapazität überblicken können, ist zur Teilnahme eine verpflichtende aber unverbindliche <a href="https://ola.pads.ccc.de/haskell-workshop-2017a">vorherige Anmeldung</a> nötig.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<!--more-->
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das dreiundzwanzigste Treffen am 23. Februar 2017</title>
    <link href="http://curry-club-augsburg.de/posts/2017-01-01-dreiundzwanzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2017-01-01-dreiundzwanzigstes-treffen.html</id>
    <published>2017-01-01T00:00:00Z</published>
    <updated>2017-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das dreiundzwanzigste Treffen am 23. Februar 2017</h1>
    <div class="info">
      Gepostet am  1. Jan 17
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Uwap wird eine Einführung in Lineare Logik und lineare Typsysteme geben.</p>
<p>Tim wird die experimentelle Programmiersprache Frank (<a href="https://arxiv.org/pdf/1611.09259.pdf">Paper</a>, <a href="https://github.com/cmcl/frankjnr">Implementierung</a>) vorstellen. In Frank gibt es Werte und Berechnungen. Jede Berechnung ist dabei getaggt mit den Effekten, die sie ausführen möchte. Berechnungen können an Funktionen übergeben werden. Beim Aufruf einer Berechnung müssen entweder Handler für ihre benötigten Effekte angegeben werden oder diese Effekte werden im Typsystem weiter nach außen propagiert (damit müssen sie weiter außen gehandhabt werden).</p>
<p>Vorteile von Frank sind:</p>
<ul>
<li>Es ist sehr einfach und natürlich, Code mit Nebeneffekten so abstrakt zu schreiben, dass man ihn in verschiedenen Kontexten verwenden kann und auch gut testen kann.</li>
<li>Man kann rein funktionalen und effektbehafteten Code sehr gut kombinieren: In Haskell ruft man ja rein funktionalen Code aus IO-Actions auf, aber man kann nicht andersrum eine IO-Action in rein funktionalem Code verwenden. Dies führt dazu, dass viele Funktionen in einer rein funktionalen und in einer IO/monadischen Variante existieren, wie z.B. <code>map</code> und <code>mapM</code> (beide wenden eine Funktion auf jedes Element einer Liste an). In Frank hat man stattdessen eine Funktion <code>map : {X -&gt; Y} -&gt; List X -&gt; List Y</code>, die man sowohl auf effektfreie Funktionen, als auch auf effektbehaftete Berechnungen anwenden kann.</li>
</ul>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das zweiundzwanzigste Treffen am 26. Januar 2017</title>
    <link href="http://curry-club-augsburg.de/posts/2016-12-19-zweiundzwanzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-12-19-zweiundzwanzigstes-treffen.html</id>
    <published>2016-12-19T00:00:00Z</published>
    <updated>2016-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das zweiundzwanzigste Treffen am 26. Januar 2017</h1>
    <div class="info">
      Gepostet am 19. Dez 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Marc erklärt die Curry–Howard-Korrespondenz (vermöge der Beweisen und Programmieren dasselbe sind) und anschließend leitet Profpatsch eine gemeinsame Programmiersitzung an.</p>
<p><a href="https://github.com/quchen/">quchen</a> wird einen Vortrag über STG halten und so erklären, wie Haskell eigentlich ausgeführt wird.</p>
<p>Manuel hält (vielleicht auch erst beim 23. Treffen) einen Vortrag mit dem Titel <em>Kenn dein Limit</em>.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Dritter großer Haskell-Workshop des Curry Clubs Augsburg am 17. Dezember 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-12-06-dritter-workshop.html" />
    <id>http://curry-club-augsburg.de/posts/2016-12-06-dritter-workshop.html</id>
    <published>2016-12-06T00:00:00Z</published>
    <updated>2016-12-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Dritter großer Haskell-Workshop des Curry Clubs Augsburg am 17. Dezember 2016</h1>
    <div class="info">
      Gepostet am  6. Dez 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <div class="right">
<p><a href="/files/haskellworkshop-plakat3.pdf"> <img width="300" src="/files/haskellworkshop-plakat3.png" /> </a></p>
</div>
<p>Liebe Freundinnen der Sonne!</p>
<p>Wir, der Curry Club Augsburg, laden alle Interessierten herzlich zu der Fortsetzung unseres <strong>Haskell-Workshops</strong> ein. Diese findet am <strong>17. Dezember 2016</strong>, einem Samstag, von 9:00 Uhr bis 17:00 Uhr im <strong>OpenLab Augsburg</strong> statt. Wie bei den vorherigen Malen ist die Teilnahme kostenlos.</p>
<p>Zielgruppe des Workshops sind alle Teilnehmerinnen der ersten beiden Workshops sowie ganz besonders Einsteigerinnen auf allen Fortschrittslevels.</p>
<p>Mit den Teilnehmerinnen vom letzten Mal werden wir dort weitermachen, wo wir das letzte Mal aufgehört haben.</p>
<p>Für Neueinsteigerinnen wird es eine eigene Gruppe geben. Teilnahmevoraussetzung für Neulinge ist entweder Erfahrung mit einer beliebigen anderen Programmiersprache oder Vertrautheit mit mathematisch/abstraktem Denken.</p>
<p>Damit wir unsere Kapazität überblicken können, ist zur Teilnahme eine unverbindliche <a href="https://ola.pads.ccc.de/haskell-workshop-2016">vorherige Anmeldung</a> nötig. Zum Zeitpunkt des Schreibens sind nur noch drei Plätze frei.</p>
<p>Wir freuen uns auf euch!</p>
<p>Euer Team vom Curry Club</p>
<!--more-->
<blockquote>
<p>Was ist schneller als C++, prägnanter als Perl, regelmäßiger als Python, flexibler als Ruby, typisierter als C#, robuster als Java und hat absolut nichts mit PHP gemeinsam? Es ist Haskell!</p>
<p>Haskell ist eine moderne und innovative Programmiersprache, die sich von bekannten imperativen Sprachen in vielerlei Hinsicht deutlich unterscheidet: Ein Haskell-Programm besteht nicht etwa aus einer Abfolge von auszuführenden Anweisungen, sondern aus einer Ansammlung von Deklarationen, deren Reihenfolge keine Rolle spielt. Auch gibt es keine veränderlichen Variablen, und ausgewertet wird nur, was wirklich benötigt wird; unendliche Datenstrukturen sind möglich und sinnvoll.</p>
<p>Dieses Denkparadigma mag anfangs sehr ungewohnt sein, zieht jedoch eine Reihe von Vorteilen mit sich: Da es keine Nebenwirkungen wie beispielsweise globale Variablen gibt, kann man Code rein lokal verstehen. Damit wird es einfacher, modular Komponenten zusammenzubauen, sich Datenflüsse klarzumachen und Code auf seine Korrektheit hin zu überprüfen. Insbesondere vereinfacht sich die Programmierung mit Threads enorm.</p>
<p>Ferner ist Haskells starkes statisches Typsystem eine große Hilfe beim Programmieren und verhindert viel mehr Fehler schon während des Kompilierens, als man vielleicht aus anderen Sprachen gewohnt ist. Es gibt das Motto, dass, wenn Haskell-Code erst einmal erfolgreich durchkompiliere, er dann auch schon korrekt sei. Das ist sicherlich übertrieben, hat aber einen erstaunlich wahren Kern.</p>
<p>Beim Erlernen von Haskell lernt man viele neue Herangehensweisen kennen, die auch in anderen Sprachen nützlich sind; das ist einer der Hauptvorteile an Haskell, der auch dann noch relevant ist, wenn man aus verschiedenen Gründen im täglichen Leben nicht in Haskell programmieren möchte.</p>
</blockquote>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das einundzwanzigste Treffen am 1. Dezember 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-11-06-einundzwanzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-11-06-einundzwanzigstes-treffen.html</id>
    <published>2016-11-06T00:00:00Z</published>
    <updated>2016-11-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das einundzwanzigste Treffen am 1. Dezember 2016</h1>
    <div class="info">
      Gepostet am  6. Nov 16
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Makarius gibt eine Einführung in die Grundlagen von klassischer Logik höherer Ordnung mit Hilberts Auswahloperator.</p>
<ul>
<li>History of Higher-Order Logic</li>
<li>Implementations of HOL</li>
<li>Quasi-programming in Isabelle/HOL</li>
<li>Isabelle foundations: primitive inferences, object-logic rules, rule composition, structured proofs Foundations of Higher-Order Logic: actual Isabelle/HOL, Pure bootstrap of HOL</li>
<li>Isabelle theory with some exercises (for Isabelle2016-1)</li>
</ul>
<p>Anschließend leitet Profpatsch eine gemeinsame Programmiersitzung an.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das zwanzigste Treffen am 3. November 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-10-07-zwanzigstes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-10-07-zwanzigstes-treffen.html</id>
    <published>2016-10-07T00:00:00Z</published>
    <updated>2016-10-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das zwanzigste Treffen am 3. November 2016</h1>
    <div class="info">
      Gepostet am  7. Okt 16
      
          von Tim Baumann
      
    </div>
    
    
  </header>

  <p>Ingo setzte seine Vorstellung von Superturingmaschinen und deren effektiven Topos <a href="/posts/2016-09-06-neunzehntes-treffen.html">vom letzten Treffen</a> fort (<a href="http://rawgit.com/iblech/mathezirkel-kurs/master/superturingmaschinen/slides.pdf">Folien</a>).</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/7QQ4Z8QwXUc" frameborder="0" allowfullscreen>
</iframe>
<p>Richard gab eine kurze Einführung in die Programmiersprache <a href="http://julialang.org/">Julia</a>.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/KUtNGWBt3hc" frameborder="0" allowfullscreen>
</iframe>
<p>Profpatsch gab, anlässlich des am folgenden Wochenende stattfindenden NixOS-Hackathons, einen kurzen Überblick über die funktionalen Grundlagen des Nix-Paketmanagers.</p>
<hr />
<p>Superturingmaschinen können anders als ihre bekannten Verwandten “länger als unendlich lange” laufen. Das drückt sich mathematisch dadurch aus, dass die Nummer des aktuellen Zeitschritts nicht mehr eine natürliche Zahl sein muss (Zeitschritt 0, Zeitschritt 1, …), sondern auch eine sog. unendliche Ordinalzahl sein kann (Zeitschritt ω, Zeitschritt ω+1, …).</p>
<p>Viele Probleme, die für gewöhnliche Turingmaschinen unlösbar sind, erledigen Superturingmaschinen mit Links: Zum Beispiel können Superturingmaschinen leicht zahlentheoretische Vermutungen überprüfen (einfach alle Zahlen durchgehen und nach einem Gegenbeispiel suchen; wenn nach unendlich vielen Schritten keines gefunden wurde, stimmt die Vermutung) oder entscheiden, ob eine gewöhnliche Turingmaschine anhält oder nicht.</p>
<p>Superturingmaschinen können aber trotzdem längst nicht “alles”. Es gibt Probleme, die auch Superturingmaschinen bewiesenermaßen nicht lösen können.</p>
<p>Der Vortrag wird in die Theorie der Superturingmaschinen einführen, welche in mancherlei Hinsicht parallel zur klassischen Theorie verläuft, sich in manchen Punkten aber auch deutlich von ihr unterscheidet. Wir werden unter anderem folgende Facetten diskutieren:</p>
<ul>
<li><p>Wie geht man präzise mit mehr als unendlich vielen Zeitschritten um? Wie kann man sich Superturingmaschinen physikalisch vorstellen? (Kurzer Crashkurs in Ordinalzahlen.)</p></li>
<li><p>Nach der kleinsten unendlich großen Ordinalzahl gibt es eine echte Klasse weiterer unendlich großer Ordinalzahlen. Gibt es zu jeder solchen Zahl eine Superturingmaschine, die nach genau so vielen Schritten hält?</p></li>
<li><p>Man schreibt Superturingmaschinen keine Maximalzahl zu verwendender Zeitschritte vor. Erstaunlicherweise gibt es trotzdem einen gewissen transfiniten Zeitpunkt, ab dem sich eine Superturingmaschine in ihrem Verhalten endlos wiederholen wird.</p></li>
<li><p>Wo liegen die Grenzen des Möglichen für Superturingmaschinen?</p></li>
<li><p>Manchmal kann man zwar ein gewisses Lied erkennen, wenn man es hört, es aber nicht vorsingen. Bei Superturingmaschinen gibt es dieses <em>Lost-Melody-Phänomen</em> ebenfalls: Sie können entscheiden, ob auf dem Band ein gewisser vorgegebener Inhalt steht, sind aber nicht in der Lage, diesen Inhalt selbst zu produzieren. Wieso?</p></li>
<li><p>Jedes Berechenbarkeitskonzept – wie etwa das von realen Computern in der realen Welt, das von idealisierten Turingmaschinen und das von Superturingmaschinen – zieht ein mathematisches Alternativuniversum mit jeweils eigenen Gesetzen der Logik mit sich, einen “effektiven Topos”. Insbesondere das Universum, welches zu Superturingmaschinen gehört, hat faszinierende Eigenschaften.</p></li>
</ul>
<p>Originalquellen zum Thema sind der wegweisende Artikel von Joel Hamkins und Andy Lewis <a href="http://arxiv.org/abs/math/9808093">Infinite Time Turing Machines</a> (Vorsicht Spoiler!) und zwei schöne Aufsätze von Andrej Bauer: <a href="http://math.andrej.com/wp-content/uploads/2014/03/real-world-realizability.pdf">Intuitionistic Mathematics and Realizability in the Physical World</a> und <a href="http://math.andrej.com/data/c2c.pdf">Realizability as the Connection between Computable and Constructive Mathematics</a>. Um den Vortrag genießen zu können, sollte man nur in seinem Leben irgendwann einmal gelernt haben, was eine Turingmaschine ist (das erste Drittel des Wikipedia-Eintrags genügt dazu völlig). Weitere Vorkenntnisse werden nicht vorausgesetzt.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das neunzehnte Treffen am 6. Oktober 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-09-06-neunzehntes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-09-06-neunzehntes-treffen.html</id>
    <published>2016-09-06T00:00:00Z</published>
    <updated>2016-09-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das neunzehnte Treffen am 6. Oktober 2016</h1>
    <div class="info">
      Gepostet am  6. Sep 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Profpatsch setzte seine Vorstellung einer pragmatischen Implementierung von Internationalisierung (i18n) in Haskell fort.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/0N5fiDPMA7Q" frameborder="0" allowfullscreen>
</iframe>
<p>Ingo begann seine Einführung in Superturingmaschinen. Da er nicht fertig geworden ist, wird der Vortrag beim nächsten Treffen fortgesetzt.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/sUqwFbbwHQo" frameborder="0" allowfullscreen>
</iframe>
<p>Superturingmaschinen können anders als ihre bekannten Verwandten “länger als unendlich lange” laufen. Das drückt sich mathematisch dadurch aus, dass die Nummer des aktuellen Zeitschritts nicht mehr eine natürliche Zahl sein muss (Zeitschritt 0, Zeitschritt 1, …), sondern auch eine sog. unendliche Ordinalzahl sein kann (Zeitschritt ω, Zeitschritt ω+1, …).</p>
<p>Viele Probleme, die für gewöhnliche Turingmaschinen unlösbar sind, erledigen Superturingmaschinen mit Links: Zum Beispiel können Superturingmaschinen leicht zahlentheoretische Vermutungen überprüfen (einfach alle Zahlen durchgehen und nach einem Gegenbeispiel suchen; wenn nach unendlich vielen Schritten keines gefunden wurde, stimmt die Vermutung) oder entscheiden, ob eine gewöhnliche Turingmaschine anhält oder nicht.</p>
<p>Superturingmaschinen können aber trotzdem längst nicht “alles”. Es gibt Probleme, die auch Superturingmaschinen bewiesenermaßen nicht lösen können.</p>
<p>Der Vortrag wird in die Theorie der Superturingmaschinen einführen, welche in mancherlei Hinsicht parallel zur klassischen Theorie verläuft, sich in manchen Punkten aber auch deutlich von ihr unterscheidet. Wir werden unter anderem folgende Facetten diskutieren:</p>
<ul>
<li><p>Wie geht man präzise mit mehr als unendlich vielen Zeitschritten um? Wie kann man sich Superturingmaschinen physikalisch vorstellen? (Kurzer Crashkurs in Ordinalzahlen.)</p></li>
<li><p>Nach der kleinsten unendlich großen Ordinalzahl gibt es eine echte Klasse weiterer unendlich großer Ordinalzahlen. Gibt es zu jeder solchen Zahl eine Superturingmaschine, die nach genau so vielen Schritten hält?</p></li>
<li><p>Man schreibt Superturingmaschinen keine Maximalzahl zu verwendender Zeitschritte vor. Erstaunlicherweise gibt es trotzdem einen gewissen transfiniten Zeitpunkt, ab dem sich eine Superturingmaschine in ihrem Verhalten endlos wiederholen wird.</p></li>
<li><p>Wo liegen die Grenzen des Möglichen für Superturingmaschinen?</p></li>
<li><p>Manchmal kann man zwar ein gewisses Lied erkennen, wenn man es hört, es aber nicht vorsingen. Bei Superturingmaschinen gibt es dieses <em>Lost-Melody-Phänomen</em> ebenfalls: Sie können entscheiden, ob auf dem Band ein gewisser vorgegebener Inhalt steht, sind aber nicht in der Lage, diesen Inhalt selbst zu produzieren. Wieso?</p></li>
<li><p>Jedes Berechenbarkeitskonzept – wie etwa das von realen Computern in der realen Welt, das von idealisierten Turingmaschinen und das von Superturingmaschinen – zieht ein mathematisches Alternativuniversum mit jeweils eigenen Gesetzen der Logik mit sich, einen “effektiven Topos”. Insbesondere das Universum, welches zu Superturingmaschinen gehört, hat faszinierende Eigenschaften.</p></li>
</ul>
<p>Originalquellen zum Thema sind der wegweisende Artikel von Joel Hamkins und Andy Lewis <a href="http://arxiv.org/abs/math/9808093">Infinite Time Turing Machines</a> (Vorsicht Spoiler!) und zwei schöne Aufsätze von Andrej Bauer: <a href="http://math.andrej.com/wp-content/uploads/2014/03/real-world-realizability.pdf">Intuitionistic Mathematics and Realizability in the Physical World</a> und <a href="http://math.andrej.com/data/c2c.pdf">Realizability as the Connection between Computable and Constructive Mathematics</a>. Um den Vortrag genießen zu können, sollte man nur in seinem Leben irgendwann einmal gelernt haben, was eine Turingmaschine ist (das erste Drittel des Wikipedia-Eintrags genügt dazu völlig). Weitere Vorkenntnisse werden nicht vorausgesetzt.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das siebzehnte Treffen am 11. August 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-06-29-siebzehntes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-06-29-siebzehntes-treffen.html</id>
    <published>2016-06-29T00:00:00Z</published>
    <updated>2016-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das siebzehnte Treffen am 11. August 2016</h1>
    <div class="info">
      Gepostet am 29. Jun 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>uwap stellte Idris als “general purpose”-Sprache vor, in der man abhängige Typen praktisch verwenden kann.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/DhznnY59Lu4" frameborder="0" allowfullscreen>
</iframe>
<p>Tim hielt spontan einen Vortrag über <a href="https://github.com/timjb/quantities">quantities</a>, eine von ihm geschriebene Idris-Bibliothek zum Rechnen mit physikalischen Einheiten.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/PrNVF2tWaVs" frameborder="0" allowfullscreen>
</iframe>
<p>Tim hielt einen Vortrag zu Versionskontrollsystemen und Patch-Theorie. Er stellte die unterschiedlichen Modelle von git und darcs vor. Eigentlich wollte er noch insbesondere auf das neue Versionskontrollsystem <a href="http://pijul.org/">Pijul</a> eingehen, welches aufgebaut ist auf (oder ist laut Webseite “inspiriert ist von”) einer kategorientheoretischen <a href="http://www.lix.polytechnique.fr/Labo/Samuel.Mimram/docs/mimram_ctp.pdf">Theorie von</a> <a href="http://www.lix.polytechnique.fr/Labo/Samuel.Mimram/docs/mimram_ctp_slides.pdf">Patches</a> von Samuel Mimram und Cinzia Di Giusto. Tim musste aber leider kurz vor dem Vortrag feststellen, dass das Paper fehlerhaft ist und die aktuelle Version von Pijul nicht funktioniert.</p>
<p>[Kurze Werbepause: Das Idee des Papers ist richtig cool! Die Autoren gehen von der Kategorie der “normalen”, linearen Dokumente aus und wollen dann “mergen” als Pushout modellieren. Damit Patches immer gemergt werden können, sollte die Kategorie endlich kovollständig sein, damit alle Pushouts existieren. Deshalb gehen die Autoren zur freien konservativen (schon existierende Kolimiten bleiben erhalten) Kovervollständigung der Kategorie der linearen Dokumente über. Diese Kovervollständigung kann man nach einem Folklore-Theorem explizit als volle Unterkategorie der Kategorie der Prägarben auf der Kategorie der linearen Dokumente beschreiben. Im Hauptteil des Papers leiten die Autoren eine viel konkretere, graphentheoretische (aber leider falsche) Beschreibung dieser Kategorie her.]</p>
<p>Aufgrund der vortgeschrittenen Zeit wurde Profpatsch’s Vortrag verschoben.</p>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das achtzehnte Treffen am 8. September 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-06-29-achtzehntes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-06-29-achtzehntes-treffen.html</id>
    <published>2016-06-29T00:00:00Z</published>
    <updated>2016-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das achtzehnte Treffen am 8. September 2016</h1>
    <div class="info">
      Gepostet am 29. Jun 16
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <p>Marc wird über <em>Hygienische Makros: Praxis, Theorie und Implementierung am Beispiel von Scheme</em> sprechen.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/XS6P4aK6rWY" frameborder="0" allowfullscreen>
</iframe>
<p>Profpatsch stellt eine pragmatische Implementierung von Internationalisierung (i18n) in Haskell vor.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/zBEgbSuuLwU" frameborder="0" allowfullscreen>
</iframe>
<p>corny wird über <em>praktische Firewalltheorie</em> sprechen. Dabei verlassen wir kurzzeitig unseren Elfenbeinturm und schauen uns die wahre Schönheit von <em>iptables</em> an. Sobald wir diesen Realitätsschock überwunden haben, kommen wir aber wieder schnell in unsere heile Isabelle-Welt zurück. Oh nein, etwas stimmt nicht in unseren heilen Welt! Was kann das sein?</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/Yrpp8ZKWcbY" frameborder="0" allowfullscreen>
</iframe>
</article>
]]></summary>
</entry>
<entry>
    <title>Programm für das sechzehnte Treffen am 14. Juli 2016</title>
    <link href="http://curry-club-augsburg.de/posts/2016-06-15-sechzehntes-treffen.html" />
    <id>http://curry-club-augsburg.de/posts/2016-06-15-sechzehntes-treffen.html</id>
    <published>2016-06-15T00:00:00Z</published>
    <updated>2016-06-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <header>
    <h1>Programm für das sechzehnte Treffen am 14. Juli 2016</h1>
    <div class="info">
      Gepostet am 15. Jun 16
      
          von Matthias Hutzler
      
    </div>
    
    
  </header>

  <iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/tfEQzR9-hlQ?list=PLwpepnYDFK9Mtt1iy8zRVjNLVV50dDgiO" frameborder="0" allowfullscreen>
</iframe>
<p>Makarius stellte <a href="http://www.flatmap.net/cobra">Cobra</a> vor, ein modernes Framework, um Code und Beweise zu präsentieren. Cobra unterstützt Isabelle-Beweise sowie Scala- und Haskell-Code.</p>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/CratUcZGFuI?list=PLwpepnYDFK9Mtt1iy8zRVjNLVV50dDgiO" frameborder="0" allowfullscreen>
</iframe>
<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/m6k-ag8o0rI?list=PLwpepnYDFK9Mtt1iy8zRVjNLVV50dDgiO" frameborder="0" allowfullscreen>
</iframe>
<p>Ingo begann unter dem Titel <em>Was sind und was sollen die Typen?</em> eine Einführung in Typtheorie unter besonderer Beachtung von Homotopietyptheorie. Die grundlegende Motivation aus der Informatik und der Programmierpraxis sind natürlich bekannt: Man möchte zur Compilezeit Informationen über das Programmverhalten gewinnen, um fehlerhafte Programme noch vor ihrer Ausführung erkennen und ablehnen zu können.</p>
<p>Aber es ist vielleicht weniger bekannt, wie Typtheorie entstanden ist (das war nämlich lange vor den Programmiersprachen), welches Problem sie ursprünglich lösen sollte (und auch tatsächlich löst), und wie ein Typsystem aufgebaut ist.</p>
<p>Ziel des ersten Teils war, ein Grundverständnis im Lesen von Typsystemspezifikationen zu vermitteln. Es wurde extensionale und intensionale Martin-Löf-Typtheorie behandelt.</p>
<p>Homotopietyptheorie ist ein neuer Zweig der Mathematik, der Aspekte von verschiedenen anderen Teilgebieten der Mathematik auf verblüffende Art und Weise kombiniert. Es ist Teil von Voevoedskys Programm zu einer <em>univalenten Grundlegung</em> der Mathematik und basiert auf einer kürzlich entdeckten Verbindung zwischen Homotopietheorie aus der Mathematik und Typtheorie aus der Logik und theoretischen Informatik.</p>
<p>In gewöhnlichen Zugängen zu einer Grundlegung der Mathematik unterscheidet man zwischen Objekten (wie zum Beispiel natürlichen Zahlen und Mengen) und Aussagen über diese Objekte. In Homotopietyptheorie gibt es diese Unterscheidung nicht. Objekte und Aussagen über Objekte werden auf eine gemeinsame Stufe gestellt. Beweisen und Konstruieren werden miteinander identifiziert.</p>
<p>Der Vortrag setzt keine Vorkenntnisse aus Logik und Typtheorie und selbstverständlich auch keine aus Homotopietheorie voraus. Der Vortrag ist für Leute konzipiert, die sich für diese neue Bewegung in der Logik interessieren, aber nicht praktizierende Mathematikerinnen sind.</p>
<p>Er klärt folgende Fragen: Was hat es mit Homotopietyptheorie auf sich? Wie werden in Homotopietyptheorie Objekte und Aussagen miteinander vereint, auf eine Stufe gestellt? Wozu ist Homotopietyptheorie gut? Wieso und für wen ist sie interessant?</p>
<p>Ein Teil der Antwort auf die letzte Frage lautet: Homotopietyptheorie ist für Leute interessant, die computergestützt Beweise führen möchten.</p>
</article>
]]></summary>
</entry>

</feed>
